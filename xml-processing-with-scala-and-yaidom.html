<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>XML processing with Scala and yaidom</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>XML processing with Scala and yaidom</h1>
        <p>Yaidom is a uniform XML query API, written in Scala and leveraging its Collections API. Moreover, yaidom provides several specific-purpose DOM-like tree implementations offering this XML query API.</p>

<p>In this article, the yaidom library is introduced, using examples from XBRL (eXtensible Business Reporting Language).</p>


        <p class="view"><a href="https://github.com/dvreeze">View My GitHub Profile</a></p>

      </header>
      <section>
        <h3>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>This article introduces the <em>yaidom</em> library with examples taken from the domain of XBRL.</p>

<p>It is assumed that the reader knows the basics of XML, in particular XML namespaces. Some experience with XML processing in Java (e.g. JAXP) is also helpful. Finally, the reader is expected to have
some familiarity with an OO programming language, such as Java (or Scala).</p>

<p>This article introduces yaidom (with Scala) as an alternative approach to XML querying, as opposed to standardized querying using XSLT, XQuery and XPath.
The remainder of this article is organized as follows:</p>
<ol>
<li>Brief introduction to Scala and Scala Collections.</li>
<li>Brief introduction to yaidom.</li>
<li>Brief introduction to XBRL.</li>
<li>Simple yaidom query examples.</li>
<li>Namespace examples.</li>
<li>Extending yaidom for custom XML dialects.</li>
<li>Conclusion.</li>
</ol>

<p>After introducing Scala, Scala Collections and yaidom, a brief explanation of XBRL follows. As a business reporting standard, XBRL standardizes business reports in XBRL format, as so-called
XBRL instances, which are XML documents. In order to be valid, XBRL instances have to obey many requirements. The remainder of this paper shows how many of those rules are easily expressed
using yaidom and Scala. Hence yaidom is introduced in this article for expressing some rules on XBRL instances. It will be shown that using Scala and yaidom instead of standard XML query and
transformation languages actually makes sense.</p>

        <h3>
<a name="brief-scala-introduction" class="anchor" href="#brief-scala-introduction"><span class="octicon octicon-link"></span></a>Brief introduction to Scala and Scala Collections</h3>

<p>The Scala programming language is the most popular alternative to Java on the Java platform. It is object-oriented (more so than Java), and also functional (in that functions are first-class
objects). It is statically typed, but feels like a dynamically typed language (because of features like type inference).</p>

<p>Scala is a <em>safe</em> and <em>expressive</em> language, often leading to good team productity and low bug counts. Its rich <em>Collections API</em>, strong support for
<em>immutable</em> data structures, and focus on <em>expressions</em> rather than statements enables programmers to work at a higher level of abstraction than Java programmers.
The Collections API of a programming language (as part of the standard library of the language, in the cases of Java, Scala, C# etc.) says a lot about the language. So below follows some
Scala code that manipulates collections.</p>

<p>Consider a book store and some queries about books. The Scala code is as follows:</p>

<pre><code>
case class Author(firstName: String, lastName: String)
case class Book(isbn: String, title: String, authors: List[Author], price: Int)

val someBooks = List(
  Book(
    "ISBN-0-13-713526-2",
    "A First Course in Database Systems",
    List(Author("Jeffrey", "Ullman"), Author("Jennifer", "Widom")),
    85),
  Book(
    "ISBN-0-13-815504-6",
    "Database Systems: The Complete Book",
    List(Author("Hector", "Garcia-Molina"), Author("Jeffrey", "Ullman"), Author("Jennifer", "Widom")),
    100),
  Book(
    "ISBN-0-11-222222-3",
    "Hector and Jeff's Database Hints",
    List(Author("Jeffrey", "Ullman"), Author("Hector", "Garcia-Molina")),
    50),
  Book(
    "ISBN-9-88-777777-6",
    "Jennifer's Economical Database Hints",
    List(Author("Jennifer", "Widom")),
    25)
)

// Return all books that are no more expensive than 50 dollars
// Returns the last 2 of the 4 books

val cheapBooks = someBooks.filter(book => book.price <= 50)

// Return all books having Jeffrey Ullman as one of its authors
// Returns the first 3 of the 4 books

val booksByUllman = someBooks.filter(book => book.authors.exists(author => author.lastName == "Ullman"))

// Return all book authors, without duplicates

val allAuthors = someBooks.flatMap(book => book.authors).distinct

// Return all titles of books having Jeffrey Ullman as one of its authors

val bookTitlesByUllman =
  someBooks.filter(book => book.authors.exists(author => author.lastName == "Ullman")).map(book => book.title)
</code></pre>

<p>Note how the queries in prose naturally map to their counterparts in Scala code. The code shows the "what" more than the "how".
In that respect, the Scala code looks more XQuery than Java (before version 8).</p>

        <h3>
<a name="brief-yaidom-introduction" class="anchor" href="#brief-yaidom-introduction"><span class="octicon octicon-link"></span></a>Brief introduction to yaidom</h3>

<p>Why yaidom ...</p>
<p>Why not use standards such as XSLT or XQuery? (too much bridging between languages; equality semantics; etc.) ...</p>
<p>And why not use Scala XML? (poor namespace support; no uniform query API backed by multiple DOM-like implementations; etc.) ...</p>
<p>Still, you can mix technologies (XQuery and yaidom, for example) ...</p>
<p>Yaidom queries ...</p>

<h3>
<a name="brief-xbrl-introduction" class="anchor" href="#brief-xbrl-introduction"><span class="octicon octicon-link"></span></a>Brief introduction to XBRL</h3>

<p>XBRL (eXtensible Business Reporting Language) is a standard for business reporting. Many (but not all) XBRL reports are financial statements. XBRL reports ("XBRL instances") are
XML documents, following a specified structure.</p>

<p>Suppose we want to report that for a given organization ("CIK") the average number of employees in 2003 was 220, and that the corresponding numbers for 2004 and 2005 were 240 and 250, respectively.
More precisely, <em>concept</em> <code>gaap:AverageNumberEmployees</code> (described by the so-called US-GAAP XBRL <em>taxonomy</em>) has the <em>value</em> <code>220</code> in the given
<em>context</em> (organization "CIK", year 2003). Then we can report the 3 <em>facts</em> above in XBRL format as follows:</p>

<pre><code>
&lt;xbrl xmlns="http://www.xbrl.org/2003/instance" xmlns:gaap="http://xasb.org/gaap"&gt;

   &lt;context id="D-2003"&gt;
      &lt;entity&gt;
         &lt;identifier scheme="http://www.sec.gov/CIK"&gt;1234567890&lt;/identifier&gt;
      &lt;/entity&gt;
      &lt;period&gt;
         &lt;startDate&gt;2003-01-01&lt;/startDate&gt;
         &lt;endDate&gt;2003-12-31&lt;/endDate&gt;
      &lt;/period&gt;
   &lt;/context&gt;

   &lt;context id="D-2004"&gt;
      &lt;entity&gt;
         &lt;identifier scheme="http://www.sec.gov/CIK"&gt;1234567890&lt;/identifier&gt;
      &lt;/entity&gt;
      &lt;period&gt;
         &lt;startDate&gt;2004-01-01&lt;/startDate&gt;
         &lt;endDate&gt;2004-12-31&lt;/endDate&gt;
      &lt;/period&gt;
   &lt;/context&gt;

   &lt;context id="D-2005"&gt;
      &lt;entity&gt;
         &lt;identifier scheme="http://www.sec.gov/CIK"&gt;1234567890&lt;/identifier&gt;
      &lt;/entity&gt;
      &lt;period&gt;
         &lt;startDate&gt;2005-01-01&lt;/startDate&gt;
         &lt;endDate&gt;2005-12-31&lt;/endDate&gt;
      &lt;/period&gt;
   &lt;/context&gt;

   &lt;unit id="U-Pure"&gt;
     &lt;measure&gt;pure&lt;/measure&gt;
   &lt;/unit&gt;

  &lt;gaap:AverageNumberEmployees contextRef="D-2003" unitRef="U-Pure" decimals="INF"&gt;220&lt;/gaap:AverageNumberEmployees&gt;
  &lt;gaap:AverageNumberEmployees contextRef="D-2004" unitRef="U-Pure" decimals="INF"&gt;240&lt;/gaap:AverageNumberEmployees&gt;
  &lt;gaap:AverageNumberEmployees contextRef="D-2005" unitRef="U-Pure" decimals="INF"&gt;250&lt;/gaap:AverageNumberEmployees&gt;

&lt;/xbrl&gt;
</code></pre>

<p>There are many requirements that have to be met in order for an XBRL instance to be valid. The XBRL Core specification (as well as other XBRL specifications)
describes many of these requirements. There are also many common best practices that have been formalized as complementary rules. For example, the
<a href="http://www.xbrl.org/technical/guidance/FRIS-PWD-2004-11-14.htm" target="_blank">international FRIS standard</a> places additional constraints on XBRL instances.</p>

<p>The remainder of this article will show how many of those FRIS rules can be written naturally as Scala expressions using yaidom. Yaidom is in no way married to XBRL,
but XBRL validations are good XML processing examples where Scala and yaidom really shine.</p>

<h3>
<a name="simple-yaidom-queries" class="anchor" href="#simple-yaidom-queries"><span class="octicon octicon-link"></span></a>Simple yaidom queries</h3>

<p>Simple yaidom queries using uniform query API ...</p>
<p>Simple yaidom queries using specific DOM-like tree implementation ...</p>

<h3>
<a name="namespace-examples" class="anchor" href="#namespace-examples"><span class="octicon octicon-link"></span></a>Namespace examples</h3>

<p>Yaidom and namespaces ...</p>
<p>Checking used namespaces ...</p>
<p>Finding unused namespaces ...</p>

<h3>
<a name="extending-yaidom" class="anchor" href="#extending-yaidom"><span class="octicon octicon-link"></span></a>Extending yaidom for custom XML dialects</h3>

<p>Extending yaidom ...</p>
<p>Example validating order in XBRL instance ...</p>
<p>Example validating contexts in XBRL instance ...</p>
<p>Example validating facts in XBRL instance ...</p>

<h3>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>The point of yaidom ...</p>
<p>Yaidom and XBRL taxonomies ...</p>

<p>As a concluding remark, yaidom is used in production code developed at <a href="http://www.ebpi.nl" target="_blank">www.ebpi.nl</a>. Its usage in several projects has certainly helped it mature. I want to thank my colleagues Jan-Paul van der Velden, Andrea Desole, Johan Walters and Nicholas Evans for their valuable feedback on earlier versions of yaidom.</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
