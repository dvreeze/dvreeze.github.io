<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>XML processing with Scala and yaidom</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>XML processing with Scala and yaidom</h1>
        <p>Yaidom is a uniform XML query API, written in Scala and leveraging its Collections API. Moreover, yaidom provides several specific-purpose DOM-like tree implementations offering this XML query API.</p>

<p>In this article, the yaidom library is introduced, using examples from XBRL (eXtensible Business Reporting Language).</p>


        <p class="view"><a href="https://github.com/dvreeze">View My GitHub Profile</a></p>

      </header>
      <section>
        <h3>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>This article introduces the <em>yaidom</em> XML query library, using examples in the domain of <a href="https://www.xbrl.org" target="_blank">XBRL</a>
(eXtensible Business Reporting Language).</p>

<p>It is assumed that the reader has some experience with XML processing in Java (e.g. JAXP) or another OO programming language (such as Scala or C#).</p>

<p>XSLT, XQuery and XPath are standard XML transformation/query languages, yet in this article yaidom (with Scala) is introduced as an <em>alternative</em> approach to in-memory
XML querying/transformation, leveraging the Scala programming language. Still, yaidom can also be used together with standard languages such as XQuery, for example when using an
XML database.</p>

<p>The remainder of this article is organized as follows:</p>
<ol>
<li>Brief introduction to Scala and Scala Collections.</li>
<li>Brief introduction to yaidom.</li>
<li>Brief introduction to the XBRL examples.</li>
<li>Simple yaidom query examples.</li>
<li>Namespace examples.</li>
<li>Extending yaidom for custom XML dialects.</li>
<li>Conclusion.</li>
</ol>

<p>As mentioned above, after introducing Scala, Scala Collections and yaidom, a brief introduction to XBRL follows. XBRL is an XML-based business reporting standard. Business reports in XBRL
format are called <em>XBRL instances</em>. XBRL instances must obey many requirements, in order for them to be considered valid. After the brief XBRL introduction, the remainder of this paper
shows how many of these rules can be expressed using yaidom and Scala. It will be shown that using Scala and yaidom instead of standard XML query and transformation languages actually makes
expressing these rules relatively easy.</p>

        <h3>
<a name="brief-scala-introduction" class="anchor" href="#brief-scala-introduction"><span class="octicon octicon-link"></span></a>Brief introduction to Scala and Scala Collections</h3>

<p>The Scala programming language is the most popular alternative to the Java language on the Java virtual machine. It is <em>object-oriented</em> (more so than Java) and also <em>functional</em>,
in that functions are first-class objects. It is <em>statically typed</em>, but it feels like a dynamically typed language, because of features like type inference.</p>

<p>Scala is a <em>safe</em> and <em>expressive</em> language, typically leading to good productivity and low bug counts in skilled disciplined teams. Its rich <em>Collections API</em>, its strong
support for <em>immutable</em> data structures, and its focus on <em>expressions</em> rather than statements enables programmers to work at a higher level of abstraction in Scala than in Java.</p>

<p>The Collections API of a programming language (which in the case of Scala and Java is a part of the standard library of the language, not of the core language) often says a lot about the
expressive power of that language. Below follows some Scala code that manipulates collections, to illustrate Scala's expressiveness.</p>

<p>Consider a book store and some queries about books (using sample data from the Stanford University online course <em>Introduction to Databases</em>). The Scala code is as follows:</p>

<pre><code>case class Author(firstName: String, lastName: String)
case class Book(isbn: String, title: String, authors: List[Author], price: Int)

val someBooks = List(
  Book(
    "ISBN-0-13-713526-2",
    "A First Course in Database Systems",
    List(Author("Jeffrey", "Ullman"), Author("Jennifer", "Widom")),
    85),
  Book(
    "ISBN-0-13-815504-6",
    "Database Systems: The Complete Book",
    List(
      Author("Hector", "Garcia-Molina"),
      Author("Jeffrey", "Ullman"),
      Author("Jennifer", "Widom")),
    100),
  Book(
    "ISBN-0-11-222222-3",
    "Hector and Jeff's Database Hints",
    List(Author("Jeffrey", "Ullman"), Author("Hector", "Garcia-Molina")),
    50),
  Book(
    "ISBN-9-88-777777-6",
    "Jennifer's Economical Database Hints",
    List(Author("Jennifer", "Widom")),
    25)
)

// Return all books that cost no more than 50 dollars (i.e., the last 2 books)

val cheapBooks = someBooks.filter(book => book.price <= 50)

// Return all books having Jeffrey Ullman as one of its authors (i.e., the first 3 books)

def hasAuthor(book: Book, authorLastName: String): Boolean = {
  book.authors.exists(author => author.lastName == authorLastName)
}

val booksByUllman =
  someBooks.filter(book => hasAuthor(book, "Ullman"))

// Return all book authors, without duplicates

val allAuthors = someBooks.flatMap(book => book.authors).distinct

// Return all titles of books having Jeffrey Ullman as one of its authors

val bookTitlesByUllman =
  someBooks.filter(book => hasAuthor(book, "Ullman")).map(book => book.title)
</code></pre>

<p>Note how the queries in prose naturally map to their counterparts in Scala code, using a small vocabulary of <em>higher-order functions</em> such as <code>map</code>,
<code>flatMap</code> and <code>filter</code>. The code shows the <em>"what"</em> more than the <em>"how"</em>. In that respect, the Scala code is more like XQuery than Java (especially than Java before
version 8). In a sense, <em>the Scala core language along with its Collections API</em> form a <em>universal query (and transformation) language</em>. Of course, Scala is a lot more than that, but
for the purposes of this article this is a fitting description.</p>

        <h3>
<a name="brief-yaidom-introduction" class="anchor" href="#brief-yaidom-introduction"><span class="octicon octicon-link"></span></a>Brief introduction to yaidom</h3>

<p>The <em>yaidom</em> library can be used for querying XML in Scala. It interoperates very well with the Scala Collections API.</p>

<p>If Scala and its Collections API can be seen as a universal query and transformation language, then yaidom offers an <em>XML element query API</em>
that turns elements into Scala collections of elements. So yaidom can be said to turn a universal query and transformation language into an <em>XML querying and transformation
language</em>. In other words, <em>Scala + its Collections API + yaidom</em> can be seen as an "XML querying/transformation stack". Below it will become clear that yaidom can
plug in different "XML backends", thus making the "XML stack" more powerful.</p>

<p>Using the bookstore example above, some simple yaidom XML queries are shown below. The XML is as follows:</p>

<pre><code>// The book store XML

&lt;Bookstore&gt;
	&lt;Book ISBN="ISBN-0-13-713526-2" Price="85" Edition="3rd"&gt;
		&lt;Title&gt;A First Course in Database Systems&lt;/Title&gt;
		&lt;Authors&gt;
			&lt;Author&gt;
				&lt;First_Name&gt;Jeffrey&lt;/First_Name&gt;
				&lt;Last_Name&gt;Ullman&lt;/Last_Name&gt;
			&lt;/Author&gt;
			&lt;Author&gt;
				&lt;First_Name&gt;Jennifer&lt;/First_Name&gt;
				&lt;Last_Name&gt;Widom&lt;/Last_Name&gt;
			&lt;/Author&gt;
		&lt;/Authors&gt;
	&lt;/Book&gt;
	&lt;Book ISBN="ISBN-0-13-815504-6" Price="100"&gt;
		&lt;Title&gt;Database Systems: The Complete Book&lt;/Title&gt;
		&lt;Authors&gt;
			&lt;Author&gt;
				&lt;First_Name&gt;Hector&lt;/First_Name&gt;
				&lt;Last_Name&gt;Garcia-Molina&lt;/Last_Name&gt;
			&lt;/Author&gt;
			&lt;Author&gt;
				&lt;First_Name&gt;Jeffrey&lt;/First_Name&gt;
				&lt;Last_Name&gt;Ullman&lt;/Last_Name&gt;
			&lt;/Author&gt;
			&lt;Author&gt;
				&lt;First_Name&gt;Jennifer&lt;/First_Name&gt;
				&lt;Last_Name&gt;Widom&lt;/Last_Name&gt;
			&lt;/Author&gt;
		&lt;/Authors&gt;
		&lt;Remark&gt;Buy this book bundled with "A First Course" - a great deal!
		&lt;/Remark&gt;
	&lt;/Book&gt;
	&lt;Book ISBN="ISBN-0-11-222222-3" Price="50"&gt;
		&lt;Title&gt;Hector and Jeff's Database Hints&lt;/Title&gt;
		&lt;Authors&gt;
			&lt;Author&gt;
				&lt;First_Name&gt;Jeffrey&lt;/First_Name&gt;
				&lt;Last_Name&gt;Ullman&lt;/Last_Name&gt;
			&lt;/Author&gt;
			&lt;Author&gt;
				&lt;First_Name&gt;Hector&lt;/First_Name&gt;
				&lt;Last_Name&gt;Garcia-Molina&lt;/Last_Name&gt;
			&lt;/Author&gt;
		&lt;/Authors&gt;
		&lt;Remark&gt;An indispensable companion to your textbook&lt;/Remark&gt;
	&lt;/Book&gt;
	&lt;Book ISBN="ISBN-9-88-777777-6" Price="25"&gt;
		&lt;Title&gt;Jennifer's Economical Database Hints&lt;/Title&gt;
		&lt;Authors&gt;
			&lt;Author&gt;
				&lt;First_Name&gt;Jennifer&lt;/First_Name&gt;
				&lt;Last_Name&gt;Widom&lt;/Last_Name&gt;
			&lt;/Author&gt;
		&lt;/Authors&gt;
	&lt;/Book&gt;
&lt;/Bookstore&gt;
</code></pre>

<p>The yaidom queries, here written in a rather verbose way, are as follows:</p>

<pre><code>// Assume a root element called bookstore.

val someBooks = bookstore.filterChildElems(book => book.localName == "Book")

// Return all books that cost no more than 50 dollars (i.e., the last 2 books)

val cheapBooks =
  someBooks.filter(book => book.attribute(EName("Price")).toInt <= 50)

// Return all books having Jeffrey Ullman as one of its authors (i.e., the first 3 books)

def hasAuthor(book: simple.Elem, authorLastName: String): Boolean = {
  require(book.localName == "Book")

  book.findElem(e =>
    e.localName == "Author" &&
      e.getChildElem(che => che.localName == "Last_Name").text == authorLastName).isDefined
}

val booksByUllman =
  someBooks.filter(book => hasAuthor(book, "Ullman"))

// Return all book author elements (with duplicates, this time)

val allAuthors =
  someBooks.flatMap(book => book.filterElems(e => e.localName == "Author"))

// Return all titles of books having Jeffrey Ullman as one of its authors

val bookTitlesByUllman =
  someBooks.filter(book => hasAuthor(book, "Ullman")).
    map(book => book.getChildElem(e => e.localName == "Title").text)
</code></pre>

<p>Above, for clarity the queries were written more verbosely than needed. The <code>EName</code> type stands for "expanded name",
and corresponds to Java's <code>javax.lang.namespace.QName</code>, except that it does not retain the prefix, if any.</p>

<p>Why use yaidom and not Scala's own XML library? As will become apparent in this article, yaidom has very precise support for
XML namespaces, more so than Scala XML. Moreover, yaidom has a precise uniform XML query API that is offered by multiple "XML backend"
implementations. Not only does yaidom offer own native DOM-like tree implementations with different strengths and weaknesses, but
it is also possible to wrap existing XML library tree implementations (DOM, JDOM, XOM, Saxon etc.), offering the same yaidom query API.
For example, yaidom wrappers around Saxon-EE NodeInfo trees offers the best of both worlds: maturity, completeness and type-awareness
of Saxon-EE, and a Scala Collections API querying experience, using yaidom as the natural bridge. Unlike yaidom, the Scala XML library
does not offer multiple tree implementations backing the same query API.</p>

<p>Why not just use standards such as XSLT or XQuery? In many cases, advanced XQuery queries or XSLT transformations require a lot of
custom functions. That comes with the costs of bridging between the 2 "worlds": the XPath data model and the programming language.
There are also substantial semantical differences, for example because XPath equality is quite different from equality in
programming languages such as Scala or Java. Summarized, it may be desirable to use Scala and its Collections API as
<em>universal query API</em>, and use yaidom for querying collections of XML elements, as the simplest XML querying solution that works.</p>

<h3>
<a name="brief-xbrl-introduction" class="anchor" href="#brief-xbrl-introduction"><span class="octicon octicon-link"></span></a>Brief introduction to the XBRL examples</h3>

<p>XBRL (eXtensible Business Reporting Language) is a standard for business reporting. Many (but not all) XBRL reports are financial statements. XBRL reports ("XBRL instances") are
XML documents, following a specified structure.</p>

<p>Suppose we want to report that for a given organization ("CIK") the average number of employees in 2003 was 220, and that the corresponding numbers for 2004 and 2005 were 240 and 250, respectively.
More precisely, <em>concept</em> <code>gaap:AverageNumberEmployees</code> (described by the so-called US-GAAP XBRL <em>taxonomy</em>) has the <em>value</em> <code>220</code> in the given
<em>context</em> (organization "CIK", year 2003). Then we can report the 3 <em>facts</em> above in XBRL format as follows:</p>

<pre><code>&lt;xbrl xmlns="http://www.xbrl.org/2003/instance" xmlns:gaap="http://xasb.org/gaap"&gt;

   &lt;context id="D-2003"&gt;
      &lt;entity&gt;
         &lt;identifier scheme="http://www.sec.gov/CIK"&gt;1234567890&lt;/identifier&gt;
      &lt;/entity&gt;
      &lt;period&gt;
         &lt;startDate&gt;2003-01-01&lt;/startDate&gt;
         &lt;endDate&gt;2003-12-31&lt;/endDate&gt;
      &lt;/period&gt;
   &lt;/context&gt;

   &lt;context id="D-2004"&gt;
      &lt;entity&gt;
         &lt;identifier scheme="http://www.sec.gov/CIK"&gt;1234567890&lt;/identifier&gt;
      &lt;/entity&gt;
      &lt;period&gt;
         &lt;startDate&gt;2004-01-01&lt;/startDate&gt;
         &lt;endDate&gt;2004-12-31&lt;/endDate&gt;
      &lt;/period&gt;
   &lt;/context&gt;

   &lt;context id="D-2005"&gt;
      &lt;entity&gt;
         &lt;identifier scheme="http://www.sec.gov/CIK"&gt;1234567890&lt;/identifier&gt;
      &lt;/entity&gt;
      &lt;period&gt;
         &lt;startDate&gt;2005-01-01&lt;/startDate&gt;
         &lt;endDate&gt;2005-12-31&lt;/endDate&gt;
      &lt;/period&gt;
   &lt;/context&gt;

   &lt;unit id="U-Pure"&gt;
     &lt;measure&gt;pure&lt;/measure&gt;
   &lt;/unit&gt;

  &lt;gaap:AverageNumberEmployees contextRef="D-2003" unitRef="U-Pure" decimals="INF"&gt;220&lt;/gaap:AverageNumberEmployees&gt;
  &lt;gaap:AverageNumberEmployees contextRef="D-2004" unitRef="U-Pure" decimals="INF"&gt;240&lt;/gaap:AverageNumberEmployees&gt;
  &lt;gaap:AverageNumberEmployees contextRef="D-2005" unitRef="U-Pure" decimals="INF"&gt;250&lt;/gaap:AverageNumberEmployees&gt;

&lt;/xbrl&gt;
</code></pre>

<p>There are many requirements that have to be met in order for an XBRL instance to be valid. The XBRL Core specification (as well as other XBRL specifications)
describes many of these requirements. There are also many common best practices that have been formalized as complementary rules. For example, the
<a href="http://www.xbrl.org/technical/guidance/FRIS-PWD-2004-11-14.htm" target="_blank">international FRIS standard</a> places additional constraints on XBRL instances.</p>

<p>The remainder of this article will show how many of those FRIS rules can be written naturally as Scala expressions using yaidom. Yaidom is in no way married to XBRL,
but XBRL validations are good XML processing examples where Scala and yaidom really shine.</p>

<h3>
<a name="simple-yaidom-queries" class="anchor" href="#simple-yaidom-queries"><span class="octicon octicon-link"></span></a>Simple yaidom query examples</h3>

<p>The XBRL snippet above is part of <a href="http://www.xbrlsite.com/examples/comprehensiveexample/2008-04-18/sample-Instance-Proof.xml" target="_blank">this sample instance.</a></p>

<p>Before showing some queries on this XBRL instances, it should be noted that knowing only 3 yaidom query API methods to some extent means knowing them all. These 3 methods are
<code>filterChildElems</code>, <code>filterElems</code> and <code>filterElemsOrSelf</code>. They all filter elements, based on the passed element predicate function. The difference
is that they filter <em>child</em> elements, <em>descendant</em> elements, and <em>descendant-or-self</em> elements, respectively. The word "descendant" is left out from the
method names.</p>

<p>It should also be noted that methods <code>filterChildElems</code> and <code>filterElemsOrSelf</code> have shorthands <code>\</code> and <code>\\</code>, respectively.
Method <code>attributeOption</code> has shorthand <code>\@</code>. Moreover, some element predicate functions have names, such as <code>withLocalName</code> and
<code>withEName</code>.</p>

<p>Some yaidom queries on the sample XBRL instance are as follows:</p>

<pre><code>// Let's first parse the XBRL instance document

val docParser = DocumentParserUsingSax.newInstance

val doc = docParser.parse(sampleXbrlInstanceFile)

// Check that all gaap:AverageNumberEmployees facts have unit U-Pure.

val xmlNs = "http://www.w3.org/XML/1998/namespace"
val xbrliNs = "http://www.xbrl.org/2003/instance"
val gaapNs = "http://xasb.org/gaap"

val avgNumEmployeesFacts =
  doc.documentElement.filterChildElems(withEName(gaapNs, "AverageNumberEmployees"))

println(avgNumEmployeesFacts.size) // prints 7

val onlyUPure =
  avgNumEmployeesFacts.forall(fact => fact.attributeOption(EName("unitRef")) == Some("U-Pure"))
println(onlyUPure) // prints true

// Check the unit itself, minding the default namespace

val uPureUnit =
  doc.documentElement.getChildElem(e =>
    e.resolvedName == EName(xbrliNs, "unit") && (e \@ EName("id")) == Some("U-Pure"))

println(uPureUnit.getChildElem(withEName(xbrliNs, "measure")).text) // prints "pure"

// Now we get the measure element text, as QName, resolving it to an EName (expanded name)
println(uPureUnit.getChildElem(withEName(xbrliNs, "measure")).textAsResolvedQName)
// prints EName(xbrliNs, "pure")

// Knowing the units are the same, the gaap:AverageNumberEmployees facts are uniquely identified by contexts.

val avgNumEmployeesFactsByContext: Map[String, simple.Elem] =
  avgNumEmployeesFacts.groupBy(_.attribute(EName("contextRef"))).mapValues(_.head)

println(avgNumEmployeesFactsByContext.keySet)
// prints Set("D-2003", "D-2004", "D-2005", "D-2007-BS1", "D-2007-BS2", "D-2006", "D-2007")

println(avgNumEmployeesFactsByContext("D-2003").text) // prints 220
</code></pre>

<p>The uniform query API of yaidom consists of query API traits that can be combined as LEGO blocks.
Yaidom element tree implementations all mix in some or most of these query API traits. The example queries
above are not bound to any particular element implementation, but use a common query API trait, namely
<code>ScopedElemApi</code>, which is itself a combination of query API traits. This trait offers
methods like <code>filterElemsOrSelf</code>, <code>filterChildElems</code> (from trait <code>ElemApi</code>),
as well as methods to get text content, qualified names, expanded names, attributes etc. In other words,
it offers a query API abstraction that is valid for almost all element implementations.</p>

<p>Sometimes we want to use methods that are offered by specific element implementations.
The default native yaidom element implementation is <code>simple.Elem</code>. It knows about
elements and text content (as per the mixed-in <code>ScopedElemApi</code> trait), but it also
knows about comments and processing instructions. For example:</p>

<pre><code>println(doc.comments.map(_.text.trim).mkString)
// prints "Created by Charles Hoffman, CPA, 2008-03-27"

val contexts = doc.documentElement.filterChildElems(withEName(xbrliNs, "context"))
println(contexts forall (e => !e.commentChildren.isEmpty)) // prints true: all contexts have comments

// Being lazy, and forgetting about the namespace here
val facts =
  doc.documentElement.filterChildElems(withLocalName("ManagementDiscussionAndAnalysisTextBlock"))
println(facts.flatMap(e => e.textChildren.filter(_.isCData)).size >= 1) // prints true
</code></pre>

<h3>
<a name="namespace-examples" class="anchor" href="#namespace-examples"><span class="octicon octicon-link"></span></a>Namespace examples</h3>

<p>Yaidom has very precise namespace support. Like the article <a href="http://www.lenzconsulting.com/namespaces/" target="_blank">Understanding Namespaces</a>,
yaidom distinguishes qualified names from expanded names, and namespace declarations from in-scope namespaces. Their yaidom counterparts are immutable
classes <code>QName</code>, <code>EName</code>, <code>Declarations</code> and <code>Scope</code>. Having these 4 distinct concepts, their
relationships can be expressed very precisely, even in yaidom code, and even outside of the context of any particular XML tree!</p>

<p>In the example XBRL instance above, all namespace declarations are in the root element, and therefore all descendant-or-self elements have the
same in-scope namespaces. In code:</p>

<pre><code>val rootScope = doc.documentElement.scope

val sameScopeEverywhere =
  doc.documentElement.findAllElemsOrSelf.forall(e => e.scope == rootScope)

println(sameScopeEverywhere) // prints true
</code></pre>

<p>Let's consider the first FRIS rule taken from the <a href="http://www.xbrl.org/technical/guidance/FRIS-PWD-2004-11-14.htm" target="_blank">international FRIS standard</a>, expressed in yaidom.
Rule 2.1.5 states that some commonly used namespaces should use their "preferred" namespace prefixes in XBRL instances. The rule can be expressed in yaidom as follows:</p>

<pre><code>val standardScope = Scope.from(
  "xbrli" -> "http://www.xbrl.org/2003/instance",
  "xlink" -> "http://www.w3.org/1999/xlink",
  "link" -> "http://www.xbrl.org/2003/linkbase",
  "xsi" -> "http://www.w3.org/2001/XMLSchema-instance",
  "iso4217" -> "http://www.xbrl.org/2003/iso4217")

val standardPrefixes = standardScope.keySet
val standardNamespaceUris = standardScope.inverse.keySet

// Naive implementation: expects only namespace declarations in root element

def usesExpectedNamespacePrefixes(xbrlInstance: simple.Elem): Boolean = {
  val rootScope = xbrlInstance.scope
  require(xbrlInstance.findAllElemsOrSelf.forall(e => e.scope == rootScope))

  val subscope = xbrlInstance.scope.withoutDefaultNamespace filter {
    case (pref, ns) =>
      standardPrefixes.contains(pref) || standardNamespaceUris.contains(ns)
  }
  subscope.subScopeOf(standardScope)
}
</code></pre>

<p>Above, there is no useful error reporting, but that is easy to add, because the implementation is entirely in the rich Scala programming language.
In prose, method <code>usesExpectedNamespacePrefixes</code> checks that if some of the 5 namespace prefixes above are used, that they all map to the expected namespace URIs.
The method also checks the other side: if some of the namespace URIs are in-scope, then the corresponding namespace prefixes are the expected ones, with the exception that
they may be the default namespace.</p>

<p>The example above illustrates yaidom's precise support for namespaces in the uniform query API, and therefore offered by diverse element tree implementations.
Yet the namespace support goes further than that. As article <a href="http://www.lenzconsulting.com/namespaces/" target="_blank">Understanding Namespaces</a> makes clear,
namespaces are not only used in element and attribute names, but can also be used in text content and attribute values.</p>

<p>FRIS rule 2.1.7 must take namespaces in text content and attribute values into account, because it states that XBRL instances should not have any unused namespace declarations.
Yet how do we detect the use of namespaces in text content or attribute values? We know this from the XML schema(s) describing XBRL instances. For example, the <code>xbrli:measure</code>
element has type <code>xs:QName</code>. So the text content of an <code>xbrli:measure</code> should be interpreted as an "expanded name". The namespace of that expanded name is therefore
one of the namespaces used in the XBRL instance.</p>

<p>Yaidom makes it possible to code a <code>DocumentENameExtractor</code> strategy, holding information about ENames and therefore namespaces occurring in text content or attribute values.
So, looking at the XML schema(s), we can easily code such a strategy ourselves (yaidom itself has no XML Schema awareness). Then, using method <code>NamespaceUtils.findAllNamespaces</code>,
all namespaces used in the XBRL instance can be found.</p>

<p>Method <code>NamespaceUtils.findAllNamespaces</code> does not work on the default "simple" elements, however, because "simple" elements do not know their ancestry. To that extent, yaidom
offers so-called "indexed" elements, that do know their ancestry. Like "simple" elements, "indexed" elements are immutable, because they are just wrappers around a root as "simple" element along
with an "index" into that element tree. The "indexed" and "simple" elements also share most of the query API, in particular the <code>ScopedElemApi</code> query API trait.</p>

<p>Let's now implement FRIS rule 2.1.7, but only for the sample XBRL instance:</p>

<pre><code>val xbrliDocumentENameExtractor: DocumentENameExtractor = {
  // Not complete, but good enough for this example!

  new DocumentENameExtractor {

    def findElemTextENameExtractor(elem: indexed.Elem): Option[TextENameExtractor] = elem.resolvedName match {
      case EName(Some(xbrliNs), "measure") if elem.path.containsName(EName(xbrliNs, "unit")) =>
        Some(SimpleTextENameExtractor)
      case EName(Some(xbrldiNs), "explicitMember") =>
        Some(SimpleTextENameExtractor)
      case _ => None
    }

    def findAttributeValueENameExtractor(elem: indexed.Elem, attributeEName: EName): Option[TextENameExtractor] = elem.resolvedName match {
      case EName(Some(xbrldiNs), "explicitMember") if attributeEName == EName("dimension") =>
        Some(SimpleTextENameExtractor)
      case _ => None
    }
  }
}

val indexedDoc = indexed.Document(doc)

val namespaceUrisDeclared = indexedDoc.documentElement.scope.inverse.keySet

import NamespaceUtils._

// Check that the used namespaces are almost exactly those declared in the root element (approximately rule 2.1.7)

val companyNs = "http://www.example.com/company"

val usedNamespaces =
  findAllNamespaces(indexedDoc.documentElement, xbrliDocumentENameExtractor).diff(Set(xmlNs))

// The "company namespace" is an unused namespace in our sample XBRL instance
require(usedNamespaces == namespaceUrisDeclared.diff(Set(companyNs)))
</code></pre>

<p>Although yaidom itself has no XML Schema awareness, yaidom can still be useful in a context where schema-awareness is needed. For example, Saxon-EE NodeInfo objects can
be wrapped as yaidom trees, thus getting the best of Scala Collections processing and Saxon-EE XML and XML Schema support.</p>

<p>Let's now remove the unused namespaces (the "company" namespace in this example), and compare the result with the original XBRL instance. Yet how do we compare
two XML trees (as "simple" elements) for equality? In order to do so, note that namespace prefixes are irrelevant to equality comparisons, but namespace URIs do count.
(Be careful with prefixes in text content and attribute values!) Yaidom offers an XML element implementation in which namespace prefixes do not occur. These elements are
called "resolved" elements. They share much of the same query API with "simple" and "indexed" elements, but not all of it. After all, "resolved" elements do not know
about namespace prefixes, so they do not know about qualified names. Therefore they do not mix in the <code>ScopedElemApi</code> trait, but they do mix in traits like
<code>ElemApi</code> and <code>HasTextApi</code>, that is, all traits extended by <code>ScopedElemApi</code> that do not know about qualified names. Hence, "resolved"
elements still have much of the yaidom query API in common with "simple" and "indexed" elements.</p>

<p>The following code strips unused namespaces, and shows that the result is the same, when comparing the trees as "resolved" elements.</p>

<pre><code>val editedRootElem =
  stripUnusedNamespaces(indexedDoc.documentElement, xbrliDocumentENameExtractor)

val areEqual =
  resolved.Elem(indexedDoc.document.documentElement) == resolved.Elem(editedRootElem)

println(areEqual) // prints true
</code></pre>

<h3>
<a name="extending-yaidom" class="anchor" href="#extending-yaidom"><span class="octicon octicon-link"></span></a>Extending yaidom for custom XML dialects</h3>

<p>Above, all XBRL instance processing was coded as normal XML processing, mostly using yaidom "simple" and "indexed" elements. That's not very convenient. It would
be nice if we could talk about contexts, units, facts etc., instead of just XML elements that happen to be contexts, units, facts, etc. Indeed that is possible in
yaidom. We already knew that yaidom is <em>extensible</em>, in that new element implementations offering the same yaidom query API can easily be added. Yet, what's more,
yaidom can also offer support for <em>custom XML dialects</em>, such as XBRL instances (or DocBook files, or Maven POM files, or any other XML dialect described by schemas).</p>

<p>To that end, yaidom offers the <code>SubtypeAwareElemApi</code> query API trait. Whereas the <code>ElemApi</code> trait offers querying for child/descendant/descendant-or-self
elements, trait <code>SubtypeAwareElemApi</code> extends this to class hierarchies (for XML dialects), offering querying for child/descendant/descendant-or-self elements of specific
sub-types of the root class of the class hierarchy.</p>

<p>In <a href="http://dvreeze.github.io/code-snippets/xbrl-instances.html" target="_blank">this XBRL instance class hierarchy</a> we can see this action. Each part of an XBRL
instance is of type <code>XbrliElem</code> or a sub-type. Common sub-types are those for contexts, units, item facts, tuple facts, and, of course, XBRL instances themselves.
Super-type <code>XbrliElem</code> mixes in traits <code>ScopedElemApi</code> and <code>SubtypeAwareElemApi</code>. Trait <code>ScopedElemApi</code> offers the most common
yaidom element query API, as we know, and trait <code>SubtypeAwareElemApi</code> makes it easy to query for elements of specific types, with little boilerplate. The latter is used
internally in the code of the <code>XbrliElem</code> class hierarchy, but can also be used in client code, if need be.</p>

<p>For the remaining FRIS validations in this article, we will use the <code>XbrliElem</code> class hierarchy.</p>

<p>Consider FRIS rule 2.1.10. It states that there is a specific expected order of the child elements of the root element. One way to code that is as follows:</p>

<pre><code>// Assume xbrlInstance variable of type XbrlInstance

val remainingChildElems =
  xbrlInstance.findAllChildElems dropWhile {
    case e: SchemaRef => true
    case e => false
  } dropWhile {
    case e: LinkbaseRef => true
    case e => false
  } dropWhile {
    case e: RoleRef => true
    case e => false
  } dropWhile {
    case e: ArcroleRef => true
    case e => false
  } dropWhile {
    case e: XbrliContext => true
    case e => false
  } dropWhile {
    case e: XbrliUnit => true
    case e => false
  } dropWhile {
    case e: Fact => true
    case e => false
  } dropWhile {
    case e: FootnoteLink => true
    case e => false
  }

require(remainingChildElems.isEmpty)
</code></pre>

<p>Now consider FRIS rule 2.4.2 stating that all contexts must be used. It is also checked that all context references indeed refer to existing contexts.
Note in this case how friendly the XBRL instance model is compared to raw XML elements:</p>

<pre><code>val contextIds = xbrlInstance.allContextsById.keySet

val usedContextIds = xbrlInstance.findAllItems.map(_.contextRef).toSet

require(usedContextIds.subsetOf(contextIds))

// Oops, some contexts are not used, namely I-2004, D-2007-LI-ALL and I-2003
println(contextIds.diff(usedContextIds))
</code></pre>

<p>The next rule is more complex. FRIS rule 2.4.1 states that S-equal contexts should not occur. S-equality ("structural equality") is defined in the
Core XBRL specification. A good implementation of S-equality requires type information. Therefore Saxon-EE backed yaidom wrappers would be a good choice.
A very naive approximation is given below:</p>

<pre><code>def transformContextForSEqualityComparison(context: XbrliContext): resolved.Elem = {
  // Ignoring "normalization" of dates and QNames, as well as order of dimensions etc.
  val elem = context.indexedElem.elem.copy(attributes = Vector())
  resolved.Elem(elem).coalesceAndNormalizeAllText.removeAllInterElementWhitespace
}
</code></pre>

<p>Then rule 2.4.1 applied to our XBRL instance is as follows:</p>

<pre><code>val contextsBySEqualityGroup =
  xbrlInstance.allContexts.groupBy(e => transformContextForSEqualityComparison(e))

require(contextsBySEqualityGroup.size == xbrlInstance.allContexts.size)
</code></pre>

<p>As we can see, the more complex the rules, the more we profit from the fact that all code is Scala code, and that there is no needed effort in bridging
between Scala and XSLT, for example. The Scala language, its Collections API, and yaidom form a powerful combination.</p>

<p>Finally, consider FRIS rule 2.8.3, stating that concepts are either top-level or nested in tuples, but not both. Using the XBRL instance model, the code is simple:</p>

<pre><code>val topLevelConceptNames = xbrlInstance.allTopLevelFactsByEName.keySet

val nestedConceptNames =
  xbrlInstance.allTopLevelTuples.flatMap(_.findAllFacts).map(_.resolvedName).toSet

require(topLevelConceptNames.intersect(nestedConceptNames).isEmpty)
</code></pre>

<h3>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>In this article, the yaidom Scala XML query library was introduced. We used examples from XBRL. It turned out that Scala, its Collections API, and the yaidom library form a powerful precise
XML processing "stack". This is even more true when using custom yaidom "backends", such as Saxon-EE. It also turned out that yaidom makes it easy to support custom XML dialects (such as XBRL
instances), offering more type-safety and leading to less boilerplate. The extensibility of yaidom is one of its strengths, along with its precise namespace support and uniform precise element
query API (offered by numerous XML "backends").</p>

<p>The FRIS rule examples show that a programming language like Scala is a natural fit for implementing those rules. Using standards like XSLT or XQuery would require the use of many custom
functions, leading to less productivity.</p>

<p>The examples only used XBRL instances. Yet instances are described by XBRL taxonomies. These taxonomies have to obey many rules as well. Taxonomies typically span many files, and their validation
is mostly much more complex than instance validation. The advantages of using a "Scala yaidom XML stack" would even be greater than for XBRL instances.</p>

<p>As a concluding remark, yaidom is used in production code developed at <a href="http://www.ebpi.nl" target="_blank">www.ebpi.nl</a>. Its usage in several projects has certainly helped it mature. I want to thank my colleagues Jan-Paul van der Velden, Andrea Desole, Johan Walters and Nicholas Evans for their valuable feedback on earlier versions of yaidom.</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>

