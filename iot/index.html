<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Continuous monitoring enabled by IoT</title>

		<meta name="description" content="Continuous monitoring enabled by IoT">
		<meta name="description" content="Efficient delivery of reliable solutions by using yaidom">
		<meta name="author" content="Chris de Vreeze">
		<meta name="author" content="Victor den Bak">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" />

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css" id="theme">
		<link rel="stylesheet" href="css/iot-presentation.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
			{% javascript lib/html5shiv.js %}
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h4>Continuous monitoring enabled by IoT</h4>
					<h3>Efficient delivery of reliable solutions by using yaidom, a Scala XML query API</h3>
					<p>
						<small>Showing yaidom by examples using XMPP and XBRL</a></small>
					</p>
					<p>
						<br/><small>Created by <a href="https://www.linkedin.com/in/victordenbak">Victor den Bak @ EBPI</a> and
							<a href="http://dvreeze.github.io/">Chris de Vreeze @ EBPI</a></small>
					</p>
					<p>
						<br/><br/><small>Powered by <a href="http://lab.hakim.se/reveal-js">reveal.js</a></small>
					</p>
				</section>

				<section>
					<h3>IoT allows for mind-boggling new solutions</h3>
					<ul class="nobullet">
						<li class="fragment" data-fragment-index="1" style="margin-top:10px;">IoT: all devices interact with each other
							<ul>
								<li>Embedded processing, sensors and connectivity</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="2" style="margin-top:50px;">Domotics most visible and widespread application
							<ul>
								<li>Thermostat, smart fridge</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="3" style="margin-top:50px;">Emerging valuable solutions
							<ul>
								<li>E-health, cars</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h3>Continuous monitoring</h3>
					<ul class="nobullet">
						<li class="fragment" data-fragment-index="1">IoT enables performance monitoring of complex systems
							<ul>
								<li>Food quality, hazmat industry, transportation safety, ...</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="2" style="margin-top:40px;">Society calls for increased and consistent quality control
							<ul>
								<li>Fading public trust in government and industry</li>
								<li>Strong increase in private quality labels</li>
								<li>Incidents show errors could have been spotted earlier</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="3" style="margin-top:40px;">Fills gap between expert judgment and quality by design
							<ul>
								<li>Low cost number crunching; monitor entire value chains</li>
								<li>Realtime insights; faster response times</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h3>Challenges for developers</h3>
					<ul class="nobullet">
						<li class="fragment" data-fragment-index="1">Continuous monitoring is complicated for many reasons
							<ul>
								<li>Eleborate structured data formats</li>
								<li>Complex business rules</li>
								<li>Not built for IoT</li>
								<li>Trust requires high quality</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="2" style="margin-top:10px;">Demanding requirements posed on developers
							<ul>
								<li>Data quality is essential</li>
								<li>Incompatible raw data</li>
								<li>Quick time to market</li>
								<li>Reuse of proven modules</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="3" style="margin-top:10px;">Developers need to use appropriate tools
							<ul>
								<li>Two such tools: <em>Scala</em> language and <em>yaidom</em> XML library</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h3>What is yaidom?</h3>
 					<ul>
						<li class="fragment" data-fragment-index="1">An <em>XML query</em> and transformation API</li>
						<li class="fragment" data-fragment-index="2">Leverages <em>Scala</em> and the Scala Collections API</li>
						<li class="fragment" data-fragment-index="3">The XML query API is small and uniform</li>
						<li class="fragment" data-fragment-index="4">It is offered by multiple element implementations</li>
						<li class="fragment" data-fragment-index="5">Including your own custom ones</li>
						<li class="fragment" data-fragment-index="6">Very precise XML namespace support</li>
						<li class="fragment" data-fragment-index="7">Full control over XML parsing and serialization</li>
						<li class="fragment" data-fragment-index="8">In short, a useful XML library when using Scala to write complex (XML) <em>validations</em></li>
					</ul>
				</section>

				<section>
					<h3>Yaidom examples</h3>
					<ul>
						<li class="fragment" data-fragment-index="1">Yaidom is shown by example code</li>
						<li class="fragment" data-fragment-index="2">Some examples use an <em>XMPP</em> message with sensor data</li>
						<li class="fragment" data-fragment-index="3">Other examples use an <em>XBRL instance</em> (financial report)</li>
						<li class="fragment" data-fragment-index="4">At a low level of abstraction, this is all "just" XML
							<ul>
								<li>Yaidom brings a Scala Collections "experience" to XML</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="5">At a higher level of abstraction, XMPP and XBRL are different (groups of) "XML dialects"
							<ul>
								<li>Yaidom also facilitates the creation of higher level data models</li>
								<li>By distinguishing between rich data models and (validation) behaviour, little code is spent on behaviour</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h3>Introducing Scala for-comprehensions</h3>
						<p>First a minimal "introduction to Scala":
							<pre><code data-trim class="scala">
val someNumbers = (0 until 10)

val evenNumbers = someNumbers.filter(i => i % 2 == 0)

// As for-comprehension, we get the same result

val evenNumbers2 =
  for {
    i <- someNumbers
    if i % 2 == 0
  } yield i
							</code></pre>
							<pre><code data-trim class="scala">
val powers = someNumbers.map(i => i * i)

// As for-comprehension, we get the same result

val powers2 =
  for {
    i <- someNumbers
  } yield i * i
							</code></pre>
						</p>
				</section>

				<section>
					<section>
						<h3>Yaidom examples</h3>
						<ul>
							<li>Suppose we use some XMPP client library (<a href="http://sco0ter.bitbucket.org/babbler/">Babbler</a>?)</li>
							<li>And we want to add support for XEP-0323 (sensor data)</li>
							<li>Using yaidom for parsing/creating the appropriate XML</li>
							<li>Then we must at least be able to query sensor data XML</li>
							<li>So in the first example some yaidom querying of (XMPP) sensor data is shown</li>
						</ul>
					</section>
					<section>
						<pre style="font-size:20px;line-height:14px;padding:15px;">
&lt;message from='device@clayster.com' to='client@clayster.com/amr'&gt;<br/>
  &lt;fields xmlns='urn:xmpp:iot:sensordata' seqnr='4'&gt;<br/>
    &lt;node nodeId='Device01'&gt;<br/>
      &lt;timestamp value='2013-03-07T19:00:00'&gt;<br/>
        <span style="background-color:gold;padding:2px;">&lt;numeric</span><br/>
          name='Temperature, Max' peak='true'<br/>
          automaticReadout='true'<br/>
          value='25.9' unit='째C'/&gt; <br/>
        <span style="background-color:gold;padding:2px;">&lt;numeric</span><br/>
          name='Temperature, Min' peak='true'<br/>
          automaticReadout='true'<br/>
          value='18.7' unit='째C'/&gt; <br/>
        <span style="background-color:gold;padding:2px;">&lt;numeric</span><br/>
          name='Temperature, Mean' computed='true'<br/>
          automaticReadout='true'<br/>
          value='22.5' unit='째C'/&gt; <br/>
      &lt;/timestamp&gt;<br/>
    &lt;/node&gt;<br/>
  &lt;/fields&gt;<br/>
&lt;/message&gt;<br/>
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h3>Yaidom examples (finding child elements)</h3>
						<ul>
							<li>Let's (repeatedly) find child elements</li>
							<li>Using yaidom verb <em>filterChildElems</em></li>
						</ul>
					</section>
					<section>
						<pre style="font-size:20px;line-height:14px;padding:15px;">
&lt;message from='device@clayster.com' to='client@clayster.com/amr'&gt;<br/>
  <span style="background-color:indianred;padding:2px;">&lt;fields</span> xmlns='urn:xmpp:iot:sensordata' seqnr='4'&gt;<br/>
    <span style="background-color:green;padding:2px;">&lt;node</span> nodeId='Device01'&gt;<br/>
      <span style="background-color:dodgerblue;padding:2px;">&lt;timestamp</span> value='2013-03-07T19:00:00'&gt;<br/>
        <span style="background-color:gold;padding:2px;">&lt;numeric</span><br/>
          name='Temperature, Max' peak='true'<br/>
          automaticReadout='true'<br/>
          value='25.9' unit='째C'/&gt; <br/>
        <span style="background-color:gold;padding:2px;">&lt;numeric</span><br/>
          name='Temperature, Min' peak='true'<br/>
          automaticReadout='true'<br/>
          value='18.7' unit='째C'/&gt; <br/>
        <span style="background-color:gold;padding:2px;">&lt;numeric</span><br/>
          name='Temperature, Mean' computed='true'<br/>
          automaticReadout='true'<br/>
          value='22.5' unit='째C'/&gt; <br/>
      <span style="background-color:dodgerblue;padding:2px;">&lt;/timestamp&gt;</span><br/>
    <span style="background-color:green;padding:2px;">&lt;/node&gt;</span><br/>
  <span style="background-color:indianred;padding:2px;">&lt;/fields&gt;</span><br/>
&lt;/message&gt;<br/>
						</pre>
					</section>
					<section>
						<h3>Yaidom examples (finding child elements)</h3>
						<p>Repeatedly finding child elements (verbosely):
							<pre><code data-trim class="scala">
val ns = "urn:xmpp:iot:sensordata"
val temperatures =
  for {
    fields <-
      message.filterChildElems(e =>
        e.resolvedName == EName(ns, "fields"))
    node <-
      fields.filterChildElems(e =>
        e.resolvedName == EName(ns, "node"))
    timestamp <-
      node.filterChildElems(e =>
        e.resolvedName == EName(ns, "timestamp"))
    num <-
      timestamp.filterChildElems(e =>
        e.resolvedName == EName(ns, "numeric"))
    if num.attribute(EName("name")).startsWith("Temperature")
  } yield num
							</code></pre>
						</p>
					</section>
					<section>
						<h3>Yaidom examples (finding child elements)</h3>
						<p>Or slightly less verbosely:
							<pre><code data-trim class="scala">
val ns = "urn:xmpp:iot:sensordata"

val temperatures =
  for {
    fields <-
      message.filterChildElems(withEName(ns, "fields"))
    node <-
      fields.filterChildElems(withEName(ns, "node"))
    timestamp <-
      node.filterChildElems(withEName(ns, "timestamp"))
    num <-
      timestamp.filterChildElems(withEName(ns, "numeric"))
    if num.attribute(EName("name")).startsWith("Temperature")
  } yield num
							</code></pre>
						</p>
					</section>
					<section>
						<h3>Yaidom examples (finding child elements)</h3>
						<p>Using "\" for filtering child elements:
							<pre><code data-trim class="scala">
val ns = "urn:xmpp:iot:sensordata"

val temperatures =
  for {
    fields <- message \ withEName(ns, "fields")
    node <- fields \ withEName(ns, "node")
    timestamp <- node \ withEName(ns, "timestamp")
    num <- timestamp \ withEName(ns, "numeric")
    if (num \@ EName("name")).getOrElse("").startsWith("Temperature")
  } yield num
							</code></pre>
						</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Yaidom examples (finding descendant elements)</h3>
						<ul>
							<li>Let's find descendant (or descendant-or-self) elements</li>
							<li>Using yaidom verbs <em>filterElems</em> and <em>filterElemsOrSelf</em></li>
							<li>The 3 element filtering verbs so far are representative of yaidom querying</li>
						</ul>
					</section>
					<section>
						<pre style="font-size:20px;line-height:14px;padding:15px;">
&lt;message from='device@clayster.com' to='client@clayster.com/amr'&gt;<br/>
  &lt;fields xmlns='urn:xmpp:iot:sensordata' seqnr='4'&gt;<br/>
    &lt;node nodeId='Device01'&gt;<br/>
      &lt;timestamp value='2013-03-07T19:00:00'&gt;<br/>
        <span style="background-color:gold;padding:2px;">&lt;numeric</span><br/>
          name='Temperature, Max' peak='true'<br/>
          automaticReadout='true'<br/>
          value='25.9' unit='째C'/&gt; <br/>
        <span style="background-color:gold;padding:2px;">&lt;numeric</span><br/>
          name='Temperature, Min' peak='true'<br/>
          automaticReadout='true'<br/>
          value='18.7' unit='째C'/&gt; <br/>
        <span style="background-color:gold;padding:2px;">&lt;numeric</span><br/>
          name='Temperature, Mean' computed='true'<br/>
          automaticReadout='true'<br/>
          value='22.5' unit='째C'/&gt; <br/>
      &lt;/timestamp&gt;<br/>
    &lt;/node&gt;<br/>
  &lt;/fields&gt;<br/>
&lt;/message&gt;<br/>
						</pre>
					</section>
					<section>
						<h3>Yaidom examples (finding descendant elements)</h3>
						<p>Finding descendant elements:
							<pre><code data-trim class="scala">
val ns = "urn:xmpp:iot:sensordata"

val temperatures =
  for {
    num <- message.filterElems(withEName(ns, "numeric"))
    if num.attribute(EName("name")).startsWith("Temperature")
  } yield num
							</code></pre>
						</p>
						<p>Finding descendant-or-self elements (same result):
							<pre><code data-trim class="scala">
val temperatures =
  for {
    num <- message.filterElemsOrSelf(withEName(ns, "numeric"))
    if num.attribute(EName("name")).startsWith("Temperature")
  } yield num
							</code></pre>
						</p>
					</section>
					<section>
						<h3>Yaidom examples (finding descendant elements)</h3>
						<p>Using "\\" for filtering descendant-or-self elements:
							<pre><code data-trim class="scala">
val ns = "urn:xmpp:iot:sensordata"

val temperatures =
  for {
    num <- message \\ withEName(ns, "numeric")
    if (num \@ EName("name")).getOrElse("").startsWith("Temperature")
  } yield num
							</code></pre>
						</p>
					</section>
				</section>

				<section>
					<h3>One query API, multiple implementations</h3>
					<ul>
						<li class="fragment" data-fragment-index="1">Default (yaidom) immutable "simple" elements</li>
						<li class="fragment" data-fragment-index="2">Immutable "indexed" elements, knowing their ancestry</li>
						<li class="fragment" data-fragment-index="3">Immutable "resolved" elements, with sensible equality</li>
						<li class="fragment" data-fragment-index="4">Yaidom wrappers for DOM</li>
						<li class="fragment" data-fragment-index="5">Yaidom wrappers for Saxon NodeInfo</li>
						<li class="fragment" data-fragment-index="6">etc.</li>
					</ul>
					<p class="fragment" data-fragment-index="7">The preceding examples work for all these implementations!</p>
					<p class="fragment" data-fragment-index="8">And they are easy to bootstrap (little code needed)</p>
				</section>

				<section> 
					<h3>Why yaidom? Why not standards like XPath, etc.?</h3>
					<ul>
						<li class="fragment" data-fragment-index="1">Staying inside Scala, not processing sequences (node sets)</li>
						<li class="fragment" data-fragment-index="2">Ease of use of (Scala) <em>programming language</em>
							<ul>
								<li>intermediate results, functions, etc.</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="3">Expressive power of <em>object-oriented</em> Scala language
							<ul>
								<li>e.g. when building layered models</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="4">Scala <em>Collections API</em> used as <em>universal query language</em></li>
						<li class="fragment" data-fragment-index="5">No XPath/XDM (XPath Data Model) pitfalls
							<ul>
								<li>XDM item equals singleton sequence with that item</li>
								<li>no nested sequences in XDM</li>
								<li>XPath "equality" (seq1 = seq2 if "overlapping"), etc.</li>
							</ul>
						</li>
						<li class="fragment" data-fragment-index="6">Very fast in querying (e.g. for "native" elements)</li>
					</ul>
				</section>

				<section>
					<section>
						<h3>Why yaidom? Why not one of many Java XML libraries?</h3>
						<ul>
							<li>Lacking Scala's Collections API</li>
							<li>Typically either leading to verbose code, or using O-X data-binding</li>
						</ul>
					</section>
					<section>
						<h3>Why yaidom? Why not Scala XML?</h3>
						<ul>
							<li>Excellent <em>namespace</em> support</li>
							<li>One <em>uniform</em> XML query API, <em>multiple</em> implementations</li>
							<li>Easy to "extend yaidom" for custom "XML dialects"
								<ul>
									<li>XMPP, XBRL etc.</li>
								</ul>
							</li>
						</ul>
					</section>
				</section>

				<section> 
					<section>
						<h3>Modeling with and on top of yaidom</h3>
						<ul>
							<li>Yaidom facilitates creation of <em>"type-safe DOM views"</em> for "XML dialects"
								<ul>
									<li>For example, XML Schema content can be modeled as a class hierarchy</li>
									<li>Yet at the same time be "normal" yaidom elements</li>
									<li>Yaidom makes it easy to query such custom elements</li>
								</ul>
							</li>
							<li>Higher level (multi-document) <em>models</em> are easy to create using Scala</li>
							<li>These models support (possibly complex) validations
								<ul>
									<li>The distinction between rich data models and behaviour makes it easy to write behaviour</li>
								</ul>
							</li>
						</ul>
					</section>
					<section>
						<p>Pseudo-code for modeling XML Schema content:
							<pre><code data-trim class="scala">
// Trait ScopedElemLike promises most of yaidom's XML query API
// Trait SubtypeAwareElemLike extends the yaidom query API to
// class hierarchies

trait ElemInXsd extends ScopedElemLike[ElemInXsd] with
  SubtypeAwareElemLike[ElemInXsd]

class XsdRootElem extends ElemInXsd

class ElementDeclaration extends ElemInXsd

// Combining schema roots in a schema

class Schema(val schemaRoots: Seq[XsdRootElem])
							</code></pre>
						</p>
					</section>
				</section>

				<section> 
					<section>
						<h3>Yaidom XBRL example</h3>
						<ul>
							<li>Let's now turn to an XBRL example</li>
							<li>XBRL is a (financial) reporting standard</li>
							<li>A business report in XBRL is called an <em>XBRL instance</em></li>
							<li>It reports <em>facts</em></li>
							<li>Having <em>contexts</em> ("who", "when" etc.)</li>
							<li>And possibly <em>units</em> ("which currency", etc.)</li>
						</ul>
					</section>
					<section>
						<pre style="font-size:17px;line-height:12px;padding:15px;">
&lt;xbrli:xbrl xmlns:xbrli="http://www.xbrl.org/2003/instance"<br/>
  xmlns:cc2-i="cc2i" xmlns:cc-t="cct" xmlns:cd="nlcd" xmlns:iso4217="iso4217"&gt;<br/>
  <span style="background-color:indianred;padding:2px;">&lt;xbrli:context</span> id="FY14d"&gt; <br/> 
    &lt;xbrli:entity&gt;<br/>
      &lt;xbrli:identifier scheme="http://www.cc.eu/cc-id"&gt;30267975<br/>
      &lt;/xbrli:identifier&gt;<br/>
    &lt;/xbrli:entity&gt;<br/>
    &lt;xbrli:period&gt;<br/>
      &lt;xbrli:startDate&gt;2014-01-01&lt;/xbrli:startDate&gt;<br/>
      &lt;xbrli:endDate&gt;2014-12-31&lt;/xbrli:endDate&gt;<br/>
    &lt;/xbrli:period&gt;<br/>
  <span style="background-color:indianred;padding:2px;">&lt;/xbrli:context&gt;</span><br/>
  <span style="background-color:green;padding:2px;">&lt;xbrli:unit</span> id="EUR"&gt;<br/>
    &lt;xbrli:measure&gt;iso4217:EUR&lt;/xbrli:measure&gt;<br/>
  <span style="background-color:green;padding:2px;">&lt;/xbrli:unit&gt;</span><br/>
  <span style="background-color:gold;padding:2px;">&lt;cc2-i:Equity</span> contextRef="FY14d" unitRef="EUR"<br/>
    decimals="INF"&gt;95000<span style="background-color:gold;padding:2px;">&lt;/cc2-i:Equity&gt;</span><br/>
  <span style="background-color:yellow;padding:2px;">&lt;cc-t:EntityAddressPresentation&gt;</span><br/>
    <span style="background-color:gold;padding:2px;">&lt;cd:POBoxNumber</span> contextRef="FY14d"&gt;2312<span style="background-color:gold;padding:2px;">&lt;/cd:POBoxNumber&gt;</span><br/>
    <span style="background-color:gold;padding:2px;">&lt;cd:PostalCodeNL</span> contextRef="FY14d"&gt;2501CD<span style="background-color:gold;padding:2px;">&lt;/cd:PostalCodeNL&gt;</span><br/>
    <span style="background-color:gold;padding:2px;">&lt;cd:PlaceOfResidenceNL</span> contextRef="FY14d"&gt;Den Haag<br/>
    <span style="background-color:gold;padding:2px;">&lt;/cd:PlaceOfResidenceNL&gt;</span><br/>
    <span style="background-color:gold;padding:2px;">&lt;cd:CountryName</span> contextRef="FY14d"&gt;Nederland<span style="background-color:gold;padding:2px;">&lt;/cd:CountryName&gt;</span><br/>
  <span style="background-color:yellow;padding:2px;">&lt;/cc-t:EntityAddressPresentation&gt;</span><br/>
&lt;/xbrli:xbrl&gt;
						</pre>
					</section>
				</section>

				<section> 
					<section>
						<h3>Yaidom XBRL example</h3>
						<ul>
							<li>Suppose we want to perform some (instance) validations</li>
							<li>Then we need to query (at least) the XBRL instance</li>
							<li>We can query the instance at a low level, as XML</li>
							<li>Using <em>filterChildElems</em> to get contexts, units and top-level facts</li>
							<li>Using <em>filterElems</em> (from top-level facts) to get nested facts</li>
							<li>Using <em>filterElemsOrSelf</em> (from top-level facts) to get all facts</li>
						</ul>
					</section>
					<section>
						<pre style="font-size:17px;line-height:12px;padding:15px;">
&lt;xbrli:xbrl xmlns:xbrli="http://www.xbrl.org/2003/instance"<br/>
  xmlns:cc2-i="cc2i" xmlns:cc-t="cct" xmlns:cd="nlcd" xmlns:iso4217="iso4217"&gt;<br/>
  <span style="background-color:indianred;padding:2px;">&lt;xbrli:context</span> id="FY14d"&gt; <br/> 
    &lt;xbrli:entity&gt;<br/>
      &lt;xbrli:identifier scheme="http://www.cc.eu/cc-id"&gt;30267975<br/>
      &lt;/xbrli:identifier&gt;<br/>
    &lt;/xbrli:entity&gt;<br/>
    &lt;xbrli:period&gt;<br/>
      &lt;xbrli:startDate&gt;2014-01-01&lt;/xbrli:startDate&gt;<br/>
      &lt;xbrli:endDate&gt;2014-12-31&lt;/xbrli:endDate&gt;<br/>
    &lt;/xbrli:period&gt;<br/>
  <span style="background-color:indianred;padding:2px;">&lt;/xbrli:context&gt;</span><br/>
  <span style="background-color:green;padding:2px;">&lt;xbrli:unit</span> id="EUR"&gt;<br/>
    &lt;xbrli:measure&gt;iso4217:EUR&lt;/xbrli:measure&gt;<br/>
  <span style="background-color:green;padding:2px;">&lt;/xbrli:unit&gt;</span><br/>
  <span style="background-color:gold;padding:2px;">&lt;cc2-i:Equity</span> contextRef="FY14d" unitRef="EUR"<br/>
    decimals="INF"&gt;95000<span style="background-color:gold;padding:2px;">&lt;/cc2-i:Equity&gt;</span><br/>
  <span style="background-color:yellow;padding:2px;">&lt;cc-t:EntityAddressPresentation&gt;</span><br/>
    <span style="background-color:gold;padding:2px;">&lt;cd:POBoxNumber</span> contextRef="FY14d"&gt;2312<span style="background-color:gold;padding:2px;">&lt;/cd:POBoxNumber&gt;</span><br/>
    <span style="background-color:gold;padding:2px;">&lt;cd:PostalCodeNL</span> contextRef="FY14d"&gt;2501CD<span style="background-color:gold;padding:2px;">&lt;/cd:PostalCodeNL&gt;</span><br/>
    <span style="background-color:gold;padding:2px;">&lt;cd:PlaceOfResidenceNL</span> contextRef="FY14d"&gt;Den Haag<br/>
    <span style="background-color:gold;padding:2px;">&lt;/cd:PlaceOfResidenceNL&gt;</span><br/>
    <span style="background-color:gold;padding:2px;">&lt;cd:CountryName</span> contextRef="FY14d"&gt;Nederland<span style="background-color:gold;padding:2px;">&lt;/cd:CountryName&gt;</span><br/>
  <span style="background-color:yellow;padding:2px;">&lt;/cc-t:EntityAddressPresentation&gt;</span><br/>
&lt;/xbrli:xbrl&gt;
						</pre>
					</section>
					<section>
						<p>Finding facts, contexts and units (as plain elements):
							<pre><code data-trim class="scala">
val ns = "http://www.xbrl.org/2003/instance"
val linkNs = "http://www.xbrl.org/2003/linkbase"

def hasCustomNs(e: Elem): Boolean = {
  !Set(Option(ns), Option(linkNs)).contains(
    e.resolvedName.namespaceUriOption)
}

val contexts = xbrlInstance.filterChildElems(withEName(ns, "context"))
val units = xbrlInstance.filterChildElems(withEName(ns, "unit"))

val topLevelFacts =
  xbrlInstance.filterChildElems(e => hasCustomNs(e))
val nestedFacts =
  topLevelFacts.flatMap(_.filterElems(e => hasCustomNs(e)))
val allFacts =
  topLevelFacts.flatMap(_.filterElemsOrSelf(e => hasCustomNs(e)))
							</code></pre>
						</p>
						<p><br/>Non-trivial queries combine facts with their contexts and units (here yaidom and Scala really shine)</p>
					</section>
				</section>

				<section> 
					<section>
						<h3>Yaidom XBRL example</h3>
						<ul>
							<li>To illustrate (low level) validations, let's find unused namespaces</li>
							<li>This is very hard in general, if namespaces occur in element content or attribute values</li>
							<li>Yaidom does not make this harder than needed</li>
							<li>You provide a <em>DocumentENameExtractor</em></li>
							<li>And yaidom finds the unused namespaces</li>
						</ul>
					</section>
					<section>
						<pre style="font-size:17px;line-height:12px;padding:15px;">
&lt;xbrli:xbrl xmlns:xbrli="http://www.xbrl.org/2003/instance"<br/>
  xmlns:cc2-i="cc2i" xmlns:cc-t="cct" xmlns:cd="nlcd" xmlns:iso4217="iso4217"<br/>
  <span style="background-color:red;padding:2px;">xmlns:unused="unused"</span>&gt;<br/>
  <span style="background-color:gold;padding:2px;">&lt;xbrli</span>:context id="FY14d"&gt; <br/> 
    &lt;xbrli:entity&gt;<br/>
      &lt;xbrli:identifier scheme="http://www.cc.eu/cc-id"&gt;30267975<br/>
      &lt;/xbrli:identifier&gt;<br/>
    &lt;/xbrli:entity&gt;<br/>
    &lt;xbrli:period&gt;<br/>
      &lt;xbrli:startDate&gt;2014-01-01&lt;/xbrli:startDate&gt;<br/>
      &lt;xbrli:endDate&gt;2014-12-31&lt;/xbrli:endDate&gt;<br/>
    &lt;/xbrli:period&gt;<br/>
  &lt;/xbrli:context&gt;<br/>
  &lt;xbrli:unit id="EUR"&gt;<br/>
    &lt;xbrli:measure&gt;<span style="background-color:orange;padding:2px;">iso4217</span>:EUR&lt;/xbrli:measure&gt;<br/>
  &lt;/xbrli:unit&gt;<br/>
  <span style="background-color:gold;padding:2px;">&lt;cc2-i</span>:Equity contextRef="FY14d" unitRef="EUR"<br/>
    decimals="INF"&gt;95000&lt;/cc2-i:Equity&gt;<br/>
  <span style="background-color:gold;padding:2px;">&lt;cc-t</span>:EntityAddressPresentation&gt;<br/>
    <span style="background-color:gold;padding:2px;">&lt;cd</span>:POBoxNumber contextRef="FY14d"&gt;2312&lt;/cd:POBoxNumber&gt;<br/>
    &lt;cd:PostalCodeNL contextRef="FY14d"&gt;2501CD&lt;/cd:PostalCodeNL&gt;<br/>
    &lt;cd:PlaceOfResidenceNL contextRef="FY14d"&gt;Den Haag<br/>
    &lt;/cd:PlaceOfResidenceNL&gt;<br/>
    &lt;cd:CountryName contextRef="FY14d"&gt;Nederland&lt;/cd:CountryName&gt;<br/>
  &lt;/cc-t:EntityAddressPresentation&gt;<br/>
&lt;/xbrli:xbrl&gt;
						</pre>
					</section>
					<section>
						<p>Finding unused namespaces:
							<pre><code data-trim class="scala">
import NamespaceUtils._

// docENameExtractor must be coded in such a way that it recognizes
// the namespace in the content of the measure element

val usedNamespaces =
  findAllNamespaces(indexed.Elem(xbrlInstance), docENameExtractor)

// Knowing that all namespace declarations are in the document element

val allNamespaces =
  xbrlInstance.scope.prefixNamespaceMap.values.toSet

val unusedNamespaces =
  allNamespaces.diff(usedNamespaces)

// This returns the namespace "unused"
							</code></pre>
						</p>
					</section>
				</section>

				<section>
					<h3>Conclusion</h3>
					<ul>
						<li>Scala and yaidom are a powerful "XML stack"</li>
						<li>With pluggable element implementations</li>
						<li>Yaidom is also extensible to specific "XML dialects"</li>
						<li>In short, yaidom and Scala are a foundation for (complex) XML validations</li>
						<li>Thus achieving data quality, and a quick time to market</li>
					</ul>
				</section>

				<section>
					<p style="font-size:70px">Any questions?</p>
					<p>
						<br/><br/><br/>
					</p>
					<p>
						<img src="logo_EBPI.jpg" alt="EBPI" width="207" height="132" style="border: none">
					</p>
					<p>
						Bezoek ook onze stand voor een inhoudelijk gesprek.
					</p>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
