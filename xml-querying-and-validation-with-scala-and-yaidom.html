<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>XML querying and validation with Scala and yaidom</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>XML querying and validation with Scala and yaidom</h1>
        <p>Yaidom is a uniform XML query API, written in Scala and leveraging its Collections API. Moreover, yaidom provides several specific-purpose DOM-like tree implementations offering this XML query API.</p>

<p>In this article, the yaidom library is introduced, using examples from XMPP (eXtensible Messaging and Presence Protocol) and XBRL (eXtensible Business Reporting Language).</p>


        <p class="view"><a href="https://github.com/dvreeze">View My GitHub Profile</a></p>

      </header>
      <section>
        <h3>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>This article introduces the <em>yaidom</em> XML query library, using examples in the domains of <a href="https://www.xbrl.org" target="_blank">XBRL</a>
(eXtensible Business Reporting Language) and <a href="http://en.wikipedia.org/wiki/XMPP" target="_blank">XMPP</a> (eXtensible Messaging and Presence Protocol). Yaidom is not coupled to any of these domains, however. Moreover, the domains of XMPP and XBRL are not in any way related, although it is quite possible to use XBRL data as "payload" in XMPP messages. Still, yaidom does make it easy to create support for specific XML domains, as will be shown later.</p>

<p>It is assumed that the reader has some experience with XML processing in Java (e.g. JAXP) or another OO programming language (such as Scala or C#).</p>

<p>XSLT, XQuery and XPath are standard XML transformation/query languages, yet in this article yaidom (with Scala) is introduced as an <em>alternative</em> approach to in-memory
XML querying/transformation and validation, leveraging the Scala programming language. Still, yaidom can also be used together with standard languages such as XQuery, for example when using an
XML database.</p>

<p>The remainder of this article is organized as follows:</p>
<ol>
<li>Brief introduction to Scala and Scala Collections.</li>
<li>Brief introduction to yaidom, using XMPP examples.</li>
<li>Brief introduction to XBRL.</li>
<li>Simple yaidom query examples.</li>
<li>Namespace validation examples.</li>
<li>Extending yaidom for custom XML dialects.</li>
<li>Conclusion.</li>
</ol>

<p>As mentioned above, after introducing Scala and Scala Collections, yaidom is introduced, using XMPP examples. After that, a brief introduction to XBRL follows. XBRL is an XML-based business reporting standard. Business reports in XBRL format are called <em>XBRL instances</em>. XBRL instances must obey many requirements, in order for them to be considered valid. After the brief XBRL introduction, the remainder of this paper shows how many of these rules can be expressed using yaidom and Scala. It will be shown that using Scala and yaidom instead of standard XML query and transformation languages actually makes expressing these rules relatively easy.</p>

        <h3>
<a name="brief-scala-introduction" class="anchor" href="#brief-scala-introduction"><span class="octicon octicon-link"></span></a>Brief introduction to Scala and Scala Collections</h3>

<p>The Scala programming language is the most popular alternative to the Java language on the Java virtual machine. It is <em>object-oriented</em> (more so than Java) and also <em>functional</em>,
in that functions are first-class objects. It is <em>statically typed</em>, but it feels like a dynamically typed language, because of features like type inference.</p>

<p>Scala is a <em>safe</em> and <em>expressive</em> language, typically leading to good productivity and low bug counts in skilled disciplined teams. Its rich <em>Collections API</em>, its strong
support for <em>immutable</em> data structures, and its focus on <em>expressions</em> rather than statements enables programmers to work at a higher level of abstraction in Scala than in Java.</p>

<p>The Collections API of a programming language (which in the case of Scala and Java is a part of the standard library of the language, not of the core language) often says a lot about the
expressive power of that language. Below follows some Scala code that manipulates collections, to illustrate Scala's expressiveness.</p>

<p>Consider a collection of sensor readings and some queries about them. The example is inspired by <a href="http://xmpp.org/extensions/xep-0323.html" target="_blank">XEP-0323: Internet of Things - Sensor Data</a>. The Scala code is as follows:</p>

<pre><code>case class NumericValue(name: String, value: String, valueUnit: String)
case class Timestamp(value: DateTime, numericValues: List[NumericValue])

val someTimestamps =
  List(
    Timestamp(
      DateTime.parse("2013-03-07T18:00:00"),
      List(
        NumericValue(name = "Temperature", value = "23.4", valueUnit = "°C"),
        NumericValue(name = "Runtime", value = "12345", valueUnit = "h"))),
    Timestamp(
      DateTime.parse("2013-03-07T19:00:00"),
      List(
        NumericValue(name = "Temperature, Max", value = "25.9", valueUnit = "°C"),
        NumericValue(name = "Temperature, Min", value = "18.7", valueUnit = "°C"),
        NumericValue(name = "Temperature, Mean", value = "22.5", valueUnit = "°C"))),
    Timestamp(
      DateTime.parse("2013-03-07T20:00:00"),
      List(
        NumericValue(name = "Temperature", value = "24.5", valueUnit = "°C"))),
    Timestamp(
      DateTime.parse("2013-03-07T21:00:00"),
      List(
        NumericValue(name = "Temperature", value = "25.1", valueUnit = "°C"))),
    Timestamp(
      DateTime.parse("2013-03-07T22:00:00"),
      List(
        NumericValue(name = "Temperature", value = "25.2", valueUnit = "°C")))
  )

// Return all timestamps until 2013-03-07T20:30:00 (i.e. the first 3 timestamps)

val someDateTime = DateTime.parse("2013-03-07T20:30:00")

val oldTimestamps =
  someTimestamps.filter(timestamp => timestamp.value.isBefore(someDateTime))

// Return all timestamps having a temperature over 25°C (i.e. the last 2 timestamps)

def hasTemperatureExceeding(timestamp: Timestamp, minTemp: Double): Boolean = {
  timestamp.numericValues.exists(v =>
    v.name == "Temperature" && v.valueUnit == "°C" && v.value.toDouble > minTemp)
}

val timestampsWithHighTemperatures =
  someTimestamps.filter(timestamp => hasTemperatureExceeding(timestamp, 25))

// Return all temperatures

val allTemperatures =
  someTimestamps.flatMap(timestamp =>
    timestamp.numericValues.filter(v => v.name == "Temperature" && v.valueUnit == "°C"))

// Return the maximum temperature

val maxTemp = allTemperatures.map(v => v.value.toDouble).max
</code></pre>

<p>Note how the queries in prose naturally map to their counterparts in Scala code, using a small vocabulary of <em>higher-order functions</em> such as <code>map</code>,
<code>flatMap</code> and <code>filter</code>. The code shows the <em>"what"</em> more than the <em>"how"</em>. In that respect, the Scala code is more like XQuery than Java (especially than Java before
version 8). In a sense, <em>the Scala core language along with its Collections API</em> form a <em>universal query (and transformation) language</em>. Of course, Scala is a lot more than that, but
for the purposes of this article this is a fitting description.</p>

        <h3>
<a name="brief-yaidom-introduction" class="anchor" href="#brief-yaidom-introduction"><span class="octicon octicon-link"></span></a>Brief introduction to yaidom, using XMPP examples</h3>

<p>The <em>yaidom</em> library can be used for querying and transforming XML in Scala. It interoperates very well with the Scala Collections API.</p>

<p>It was mentioned above that Scala and its Collections API can be used as a universal query and transformation language. The yaidom library offers an <em>XML element query API</em>
that turns elements into Scala collections of elements. So yaidom can be said to turn a universal query and transformation language into an <em>XML querying and transformation
language</em>. In other words, <em>Scala + its Collections API + yaidom</em> can be used as an "XML querying/transformation stack". Below it will become clear that yaidom can
plug in different "XML backends", thus making the "XML stack" very powerful.</p>

<p>Using the sensor data example above, some simple yaidom XML queries are shown below. The XML is as follows:</p>

<pre><code>// The sensor data XML

&lt;node nodeId="Device01" xmlns="urn:xmpp:iot:sensordata"&gt;
  &lt;timestamp value="2013-03-07T18:00:00"&gt;
    &lt;numeric name="Temperature" value="23.4" unit="°C"/&gt;
    &lt;numeric name="Runtime" value="12345" unit="h"/&gt;
  &lt;/timestamp&gt;
  &lt;timestamp value="2013-03-07T19:00:00"&gt;
    &lt;numeric name="Temperature, Max" value="25.9" unit="°C"/&gt;
    &lt;numeric name="Temperature, Min" value="18.7" unit="°C"/&gt;
    &lt;numeric name="Temperature, Mean" value="22.5" unit="°C"/&gt;
  &lt;/timestamp&gt;
  &lt;timestamp value="2013-03-07T20:00:00"&gt;
    &lt;numeric name="Temperature" value="24.5" unit="°C"/&gt;
  &lt;/timestamp&gt;
  &lt;timestamp value="2013-03-07T21:00:00"&gt;
    &lt;numeric name="Temperature" value="25.1" unit="°C"/&gt;
  &lt;/timestamp&gt;
  &lt;timestamp value="2013-03-07T22:00:00"&gt;
    &lt;numeric name="Temperature" value="25.2" unit="°C"/&gt;
  &lt;/timestamp&gt;
&lt;/node&gt;
</code></pre>

<p>Below follow the yaidom XML queries corresponding to the (non-XML) queries above. Written rather verbosely, they are as follows:</p>

<pre><code>// Assume a root element called node.

// Return all timestamps until 2013-03-07T20:30:00 (i.e. the first 3 timestamps)

val someDateTime = DateTime.parse("2013-03-07T20:30:00")

val oldTimestamps =
  node.filterChildElems(e => e.localName == "timestamp" &&
    DateTime.parse(e.attribute(EName("value"))).isBefore(someDateTime))

// Return all timestamps having a temperature over 25°C (i.e. the last 2 timestamps)

def hasTemperatureExceeding(timestamp: simple.Elem, minTemp: Double): Boolean = {
  require(timestamp.localName == "timestamp")

  val temperatures =
    timestamp.filterChildElems(e => e.attribute(EName("name")) == "Temperature" &&
      e.attribute(EName("unit")) == "°C")

  temperatures.exists(e => e.attribute(EName("value")).toDouble > minTemp)
}

val timestampsWithHighTemperatures =
  node.filterChildElems(e => e.localName == "timestamp" &&
    hasTemperatureExceeding(e, 25))

// Return all temperatures

val allTemperatures =
  node.filterElems(e => e.localName == "numeric" &&
    e.attribute(EName("name")) == "Temperature" && e.attribute(EName("unit")) == "°C")

// Return the maximum temperature

val maxTemp =
  allTemperatures.map(e => e.attribute(EName("value")).toDouble).max
</code></pre>

<p>Above, the <code>EName</code> type stands for "expanded name". It corresponds to Java's <code>javax.lang.namespace.QName</code>, except that it does not retain the prefix, if any.</p>

<p>For clarity, these XML queries were written more verbosely than needed. Even when writing these queries in a less verbose way than has been done above, there would still be some verbosity
related to XML handling. This is intentional: yaidom is a <em>precise</em> XML query API. For example, yaidom does not abstract away the distinction between elements and attributes, or between
names with a namespace and those without any namespace. Despite the syntax dedicated by yaidom to XML node manipulation, the yaidom query examples are not <em>that</em> much more verbose than the
non-XML query examples presented earlier. Compared to ad-hoc XML querying in Java (using JAXP), however, ad-hoc XML querying in Scala using yaidom is <em>much</em> less verbose. Even when invoking
XPath queries (returning node sets) from Java code, the processing of the resulting node sets would add "syntactic clutter" that the use of Scala with yaidom could have prevented.</p>

<p>Why use yaidom and not Scala's own XML library? As will become apparent in this article, yaidom has very precise support for
<em>XML namespaces</em>, more so than Scala XML. Using the yaidom API it is always clear if queries are namespace-aware. If it is intentional to query
for elements that have specific local names, regardless of the namespace, then yaidom forces the user to be explicit about that. Precise namespace
support in yaidom even goes as far as the ability to express a simple <em>theory</em> of XML namespaces (relating namespace declarations, in-scope namespaces,
"qualified names" and "expanded names") in yaidom code itself, outside of any particular XML tree!</p>

<p>There are more reasons why yaidom may be preferable to Scala's own XML library. For example, yaidom has a precise <em>uniform XML query API</em> that is offered by
<em>multiple "XML backend"</em> implementations. Not only does yaidom offer own native DOM-like tree ("XML backend") implementations with different strengths and weaknesses, but
it is also possible to wrap existing XML library tree implementations (DOM, JDOM, XOM, Saxon etc.) in yaidom, offering the same yaidom query API.
For example, yaidom wrappers around Saxon-EE <code>NodeInfo</code> trees offer the best of Saxon and the <em>Scala-yaidom</em> combination: on the one hand the completeness and
schema-type-awareness of Saxon-EE, and on the other hand a "Scala Collections API querying experience", using yaidom as the natural bridge between Saxon "nodes" and Scala collections processing.
Unlike yaidom, the Scala XML library does not offer multiple tree implementations backing the same query API.</p>

<p>Why not just use standards such as XSLT or XQuery? XBRL processing is a good example where yaidom shines, as will become clear below. After all, XBRL is a lot more than "just" XML,
so XBRL processing is a lot more than "just" XML processing. Performing most or all of this processing in Scala using yaidom offers the following advantages:</p>
<ul>
<li>The maturity and performance of the <em>Java virtual machine</em>, backed by a formal specification. This can be an advantage of programming languages such as Java and Scala
over XML standard languages, which have no (specified) native or near native runtime (but do have database support).</li>
<li>The <em>expressive power</em> of Scala and its Collections API, with yaidom bringing some of that power to XML processing. Scala's expressive power also makes it easy to build XBRL
"model layers" on top of a lower level "XML layer".</li>
<li>The <em>ease of use</em> of programming languages, such as Scala, for such mundane tasks as defining variables (typically for immutable data), calling functions, etc. While XSLT and
XQuery enforce a <em>functional programming</em> style, Scala strongly encourages such a programming style, yet without sacrificing ease of use.</li>
<li>A large <em>ecosystem</em> around Scala (and Java), offering many high quality libraries.</li>
<li>Familiar <em>semantics</em> of "equality" (as an equivalence relation) and collection processing. The XPath Data Model does not distinguish between individual items (nodes and atomic values)
on the one hand, and singleton sequences of items on the other hand, but this can be quite confusing. By contrast, in Scala's Collections API (and yaidom) an object is not the same as a singleton
collection containing that object.</li>
<li>Yaidom does not sacrifice any XML processing power. Not only are "XML backends" pluggable, but they also remain accessible, and are not hidden behind any "broken abstractions".</li>
</ul>
<p>Surely yaidom can be used with XQuery when using an XML(-enabled) database, where XQuery joins and filters database XML data into "raw result sets", which are further processed using yaidom
queries. Still, it makes sense to keep the number of boundaries between XQuery and yaidom/Scala relatively low, for each such boundary has some (syntactic and semantical) costs.
In summary, the more some XML processing task can benefit from the use of Scala, the more attractive the use of yaidom becomes.</p>

<h3>
<a name="brief-xbrl-introduction" class="anchor" href="#brief-xbrl-introduction"><span class="octicon octicon-link"></span></a>Brief introduction to XBRL</h3>

<p>So far, this article has introduced Scala and yaidom, using only simple sensor data examples. In the remainder of this article, yaidom examples in the domain of <em>XBRL</em> are used. First, this section gives a very brief introduction to XBRL.</p>

<p>XBRL (eXtensible Business Reporting Language) is a standard for business reporting. Many (but not all) XBRL reports are financial statements. XBRL reports ("XBRL instances") are
XML documents, following a specified structure.</p>

<p>Suppose we want to report that for a given organization ("CIK") the average number of employees in 2003 was 220, and that the corresponding numbers for 2004 and 2005 were 240 and 250, respectively.
More precisely, <em>concept</em> <code>gaap:AverageNumberEmployees</code> (described by the so-called US-GAAP XBRL <em>taxonomy</em>) has the <em>value</em> <code>220</code> in the given
<em>context</em> (organization "CIK", year 2003). Then we can report the 3 <em>facts</em> above in XBRL format as follows:</p>

<pre><code>&lt;xbrl xmlns="http://www.xbrl.org/2003/instance" xmlns:gaap="http://xasb.org/gaap"&gt;

   &lt;context id="D-2003"&gt;
      &lt;entity&gt;
         &lt;identifier scheme="http://www.sec.gov/CIK"&gt;1234567890&lt;/identifier&gt;
      &lt;/entity&gt;
      &lt;period&gt;
         &lt;startDate&gt;2003-01-01&lt;/startDate&gt;
         &lt;endDate&gt;2003-12-31&lt;/endDate&gt;
      &lt;/period&gt;
   &lt;/context&gt;

   &lt;context id="D-2004"&gt;
      &lt;entity&gt;
         &lt;identifier scheme="http://www.sec.gov/CIK"&gt;1234567890&lt;/identifier&gt;
      &lt;/entity&gt;
      &lt;period&gt;
         &lt;startDate&gt;2004-01-01&lt;/startDate&gt;
         &lt;endDate&gt;2004-12-31&lt;/endDate&gt;
      &lt;/period&gt;
   &lt;/context&gt;

   &lt;context id="D-2005"&gt;
      &lt;entity&gt;
         &lt;identifier scheme="http://www.sec.gov/CIK"&gt;1234567890&lt;/identifier&gt;
      &lt;/entity&gt;
      &lt;period&gt;
         &lt;startDate&gt;2005-01-01&lt;/startDate&gt;
         &lt;endDate&gt;2005-12-31&lt;/endDate&gt;
      &lt;/period&gt;
   &lt;/context&gt;

   &lt;unit id="U-Pure"&gt;
     &lt;measure&gt;pure&lt;/measure&gt;
   &lt;/unit&gt;

  &lt;gaap:AverageNumberEmployees contextRef="D-2003" unitRef="U-Pure" decimals="INF"&gt;220&lt;/gaap:AverageNumberEmployees&gt;
  &lt;gaap:AverageNumberEmployees contextRef="D-2004" unitRef="U-Pure" decimals="INF"&gt;240&lt;/gaap:AverageNumberEmployees&gt;
  &lt;gaap:AverageNumberEmployees contextRef="D-2005" unitRef="U-Pure" decimals="INF"&gt;250&lt;/gaap:AverageNumberEmployees&gt;

&lt;/xbrl&gt;
</code></pre>

<p>This example comes from a non-trivial sample XBRL instance written by Charles Hoffman, also known as "the father of XBRL".</p>

<p>There are many requirements that have to be met in order for an XBRL instance to be valid. The XBRL Core specification (as well as other XBRL specifications)
describes many of these requirements. There are also many common best practices that have been formalized as complementary rules. For example, the
<a href="http://www.xbrl.org/technical/guidance/FRIS-PWD-2004-11-14.htm" target="_blank">international FRIS standard</a> places additional constraints on XBRL instances.</p>

<p>Most of the remainder of this article will show how many validation rules can be written naturally as Scala expressions using yaidom. Yaidom is in no way married to XBRL,
but XBRL validations are good XML processing examples where Scala and yaidom really shine.</p>

<h3>
<a name="simple-yaidom-queries" class="anchor" href="#simple-yaidom-queries"><span class="octicon octicon-link"></span></a>Simple yaidom query examples</h3>

<p>The XBRL snippet above is part of <a href="http://www.xbrlsite.com/examples/comprehensiveexample/2008-04-18/sample-Instance-Proof.xml" target="_blank">this sample instance</a>.
In this section, some simple yaidom XML queries are performed on the XBRL instance.</p>

<p>Before showing these queries on this XBRL instance, it should be noted that knowing only 3 yaidom query API methods to some extent means knowing them all. These 3 methods are
<code>filterChildElems</code>, <code>filterElems</code> and <code>filterElemsOrSelf</code>. They all filter elements, based on the passed element predicate function. The difference
is that they filter <em>child</em> elements, <em>descendant</em> elements, and <em>descendant-or-self</em> elements, respectively. The word "descendant" is left out from the
method names.</p>

<p>It should also be noted that methods <code>filterChildElems</code> and <code>filterElemsOrSelf</code> have shorthands <code>\</code> and <code>\\</code>, respectively.
Method <code>attributeOption</code> has shorthand <code>\@</code>. Moreover, some element predicate functions have names, such as <code>withLocalName</code> and
<code>withEName</code>.</p>

<p>Some yaidom queries on the sample XBRL instance are as follows:</p>

<pre><code>// Let's first parse the XBRL instance document

val docParser = DocumentParserUsingSax.newInstance

val doc = docParser.parse(sampleXbrlInstanceFile)

// Check that all gaap:AverageNumberEmployees facts have unit U-Pure.

val xmlNs = "http://www.w3.org/XML/1998/namespace"
val xbrliNs = "http://www.xbrl.org/2003/instance"
val gaapNs = "http://xasb.org/gaap"

val avgNumEmployeesFacts =
  doc.documentElement.filterChildElems(withEName(gaapNs, "AverageNumberEmployees"))

println(avgNumEmployeesFacts.size) // prints 7

val onlyUPure =
  avgNumEmployeesFacts.forall(fact => fact.attributeOption(EName("unitRef")) == Some("U-Pure"))
println(onlyUPure) // prints true

// Check the unit itself, minding the default namespace

val uPureUnit =
  doc.documentElement.getChildElem(e =>
    e.resolvedName == EName(xbrliNs, "unit") && (e \@ EName("id")) == Some("U-Pure"))

println(uPureUnit.getChildElem(withEName(xbrliNs, "measure")).text) // prints "pure"

// Now we get the measure element text, as QName, resolving it to an EName (expanded name)
println(uPureUnit.getChildElem(withEName(xbrliNs, "measure")).textAsResolvedQName)
// prints EName(xbrliNs, "pure")

// Knowing the units are the same, the gaap:AverageNumberEmployees facts are uniquely identified by contexts.

val avgNumEmployeesFactsByContext: Map[String, simple.Elem] =
  avgNumEmployeesFacts.groupBy(_.attribute(EName("contextRef"))).mapValues(_.head)

println(avgNumEmployeesFactsByContext.keySet)
// prints Set("D-2003", "D-2004", "D-2005", "D-2007-BS1", "D-2007-BS2", "D-2006", "D-2007")

println(avgNumEmployeesFactsByContext("D-2003").text) // prints 220
</code></pre>

<p>The uniform query API of yaidom consists of several query API traits. They are like LEGO blocks, that can easily be combined.
Yaidom (native and wrapper) element tree implementations all mix in some or most of these query API traits. The example queries
above are not bound to any particular element implementation, but use a common query API trait, namely
<code>ScopedElemApi</code>, which is itself a combination of query API traits. This trait offers
methods like <code>filterElemsOrSelf</code>, <code>filterChildElems</code> (from trait <code>ElemApi</code>),
as well as methods to get text content, qualified names, expanded names, attributes etc. In other words,
it offers a query API abstraction that is valid for almost all element implementations.</p>

<p>The query API traits themselves are not visible in normal yaidom client code. They are relevant for creators of
custom yaidom element implementations, for example wrappers around elements offered by existing XML libraries.
Yaidom users that do not extend yaidom may still want to know which query API traits are offered by some XML tree
implementation, of course.</p>

<p>Sometimes we want to use methods that are only offered by specific element implementations, and not by any query API traits.
The default native yaidom element implementation is <code>simple.Elem</code>. It knows about
elements and text content (as per the mixed-in <code>ScopedElemApi</code> trait), but it also
knows about comments, processing instructions and CDATA sections (if passed by the XML parser). For example:</p>

<pre><code>println(doc.comments.map(_.text.trim).mkString)
// prints "Created by Charles Hoffman, CPA, 2008-03-27"

val contexts = doc.documentElement.filterChildElems(withEName(xbrliNs, "context"))
println(contexts forall (e => !e.commentChildren.isEmpty)) // prints true: all contexts have comments

// Being lazy, and forgetting about the namespace here
val facts =
  doc.documentElement.filterChildElems(withLocalName("ManagementDiscussionAndAnalysisTextBlock"))
println(facts.flatMap(e => e.textChildren.filter(_.isCData)).size >= 1) // prints true
</code></pre>

<h3>
<a name="namespace-examples" class="anchor" href="#namespace-examples"><span class="octicon octicon-link"></span></a>Namespace validation examples</h3>

<p>Yaidom has very precise namespace support. Like the article <a href="http://www.lenzconsulting.com/namespaces/" target="_blank">Understanding Namespaces</a>,
yaidom distinguishes qualified names from expanded names, and namespace declarations from in-scope namespaces. Their yaidom counterparts are immutable
classes <code>QName</code>, <code>EName</code>, <code>Declarations</code> and <code>Scope</code>. Having these 4 distinct concepts, their
relationships can be expressed very precisely, even in yaidom code, and even outside of the context of any particular XML tree!</p>

<p>In the example XBRL instance above, all namespace declarations are in the root element, and therefore all descendant-or-self elements have the
same in-scope namespaces. In code:</p>

<pre><code>val rootScope = doc.documentElement.scope

val sameScopeEverywhere =
  doc.documentElement.findAllElemsOrSelf.forall(e => e.scope == rootScope)

println(sameScopeEverywhere) // prints true
</code></pre>

<p>Let's consider the first FRIS rule taken from the <a href="http://www.xbrl.org/technical/guidance/FRIS-PWD-2004-11-14.htm" target="_blank">international FRIS standard</a>, expressed in yaidom.
Rule 2.1.5 states that some commonly used namespaces should use their "preferred" namespace prefixes in XBRL instances. The rule can be expressed in yaidom as follows:</p>

<pre><code>val standardScope = Scope.from(
  "xbrli" -> "http://www.xbrl.org/2003/instance",
  "xlink" -> "http://www.w3.org/1999/xlink",
  "link" -> "http://www.xbrl.org/2003/linkbase",
  "xsi" -> "http://www.w3.org/2001/XMLSchema-instance",
  "iso4217" -> "http://www.xbrl.org/2003/iso4217")

val standardPrefixes = standardScope.keySet
val standardNamespaceUris = standardScope.inverse.keySet

// Naive implementation: expects only namespace declarations in root element

def usesExpectedNamespacePrefixes(xbrlInstance: simple.Elem): Boolean = {
  val rootScope = xbrlInstance.scope
  require(xbrlInstance.findAllElemsOrSelf.forall(e => e.scope == rootScope))

  val subscope = xbrlInstance.scope.withoutDefaultNamespace filter {
    case (pref, ns) =>
      standardPrefixes.contains(pref) || standardNamespaceUris.contains(ns)
  }
  subscope.subScopeOf(standardScope)
}
</code></pre>

<p>Above, there is no useful error reporting, but that is easy to add, because the implementation is entirely in the rich Scala programming language.
In prose, method <code>usesExpectedNamespacePrefixes</code> checks that if some of the 5 namespace prefixes above are used, that they all map to the expected namespace URIs.
The method also checks the other side: if some of the namespace URIs are in-scope, then the corresponding namespace prefixes are the expected ones, with the exception that
they may be the default namespace.</p>

<p>The example above illustrates yaidom's precise support for namespaces in the uniform query API, and therefore offered by diverse element tree implementations.
Yet the namespace support goes further than that. As article <a href="http://www.lenzconsulting.com/namespaces/" target="_blank">Understanding Namespaces</a> makes clear,
namespaces are not only used in element and attribute names, but can also be used in text content and attribute values.</p>

<p>FRIS rule 2.1.7 must take namespaces in text content and attribute values into account, because it states that XBRL instances should not have any unused namespace declarations.
Yet how do we detect the use of namespaces in text content or attribute values? We know this from the XML schema(s) describing XBRL instances. For example, the <code>xbrli:measure</code>
element has type <code>xs:QName</code>. So the text content of an <code>xbrli:measure</code> should be interpreted as an "expanded name". The namespace of that expanded name is therefore
one of the namespaces used in the XBRL instance.</p>

<p>Yaidom makes it possible to code a <code>DocumentENameExtractor</code> strategy, holding information about ENames and therefore namespaces occurring in text content or attribute values.
So, looking at the XML schema(s), we can easily code such a strategy ourselves (yaidom itself has no XML Schema awareness). Then, using method <code>NamespaceUtils.findAllNamespaces</code>,
all namespaces used in the XBRL instance can be found.</p>

<p>Method <code>NamespaceUtils.findAllNamespaces</code> does not work on the default "simple" elements, however, because "simple" elements do not know their ancestry. To that extent, yaidom
offers so-called "indexed" elements, that do know their ancestry. Like "simple" elements, "indexed" elements are immutable, because they are just wrappers around a root as "simple" element along
with an "index" into that element tree. The "indexed" and "simple" elements also share most of the query API, in particular the <code>ScopedElemApi</code> query API trait.</p>

<p>Let's now implement FRIS rule 2.1.7, but only for the sample XBRL instance:</p>

<pre><code>val xbrliDocumentENameExtractor: DocumentENameExtractor = {
  // Not complete, but good enough for this example!

  new DocumentENameExtractor {

    def findElemTextENameExtractor(elem: indexed.Elem): Option[TextENameExtractor] = elem.resolvedName match {
      case EName(Some(xbrliNs), "measure") if elem.path.containsName(EName(xbrliNs, "unit")) =>
        Some(SimpleTextENameExtractor)
      case EName(Some(xbrldiNs), "explicitMember") =>
        Some(SimpleTextENameExtractor)
      case _ => None
    }

    def findAttributeValueENameExtractor(elem: indexed.Elem, attributeEName: EName): Option[TextENameExtractor] = elem.resolvedName match {
      case EName(Some(xbrldiNs), "explicitMember") if attributeEName == EName("dimension") =>
        Some(SimpleTextENameExtractor)
      case _ => None
    }
  }
}

val indexedDoc = indexed.Document(doc)

val namespaceUrisDeclared = indexedDoc.documentElement.scope.inverse.keySet

import NamespaceUtils._

// Check that the used namespaces are almost exactly those declared in the root element (approximately rule 2.1.7)

val companyNs = "http://www.example.com/company"

val usedNamespaces =
  findAllNamespaces(indexedDoc.documentElement, xbrliDocumentENameExtractor).diff(Set(xmlNs))

// The "company namespace" is an unused namespace in our sample XBRL instance
require(usedNamespaces == namespaceUrisDeclared.diff(Set(companyNs)))
</code></pre>

<p>Although yaidom itself has no XML Schema awareness, yaidom can still be useful in a context where schema-awareness is needed. For example, Saxon-EE NodeInfo objects can
be wrapped as yaidom trees, thus getting the best of Scala Collections processing and Saxon-EE XML and XML Schema support.</p>

<p>Let's now remove the unused namespaces (the "company" namespace in this example), and compare the result with the original XBRL instance. Yet how do we compare
two XML trees (as "simple" elements) for equality? In order to do so, note that namespace prefixes are irrelevant to equality comparisons, but namespace URIs do count.
(Be careful with prefixes in text content and attribute values!) Yaidom offers an XML element implementation in which namespace prefixes do not occur. These elements are
called "resolved" elements. They share much of the same query API with "simple" and "indexed" elements, but not all of it. After all, "resolved" elements do not know
about namespace prefixes, so they do not know about qualified names. Therefore they do not mix in the <code>ScopedElemApi</code> trait, but they do mix in traits like
<code>ElemApi</code> and <code>HasTextApi</code>, that is, all traits extended by <code>ScopedElemApi</code> that do not know about qualified names. Hence, "resolved"
elements still have much of the yaidom query API in common with "simple" and "indexed" elements.</p>

<p>The following code strips unused namespaces, and shows that the result is the same, when comparing the trees as "resolved" elements.</p>

<pre><code>val editedRootElem =
  stripUnusedNamespaces(indexedDoc.documentElement, xbrliDocumentENameExtractor)

val areEqual =
  resolved.Elem(indexedDoc.document.documentElement) == resolved.Elem(editedRootElem)

println(areEqual) // prints true
</code></pre>

<h3>
<a name="extending-yaidom" class="anchor" href="#extending-yaidom"><span class="octicon octicon-link"></span></a>Extending yaidom for custom XML dialects</h3>

<p>Above, all XBRL instance processing was coded as normal XML processing, mostly using yaidom "simple" and "indexed" elements. That's not very convenient. It would
be nice if we could talk about contexts, units, facts etc., instead of just XML elements that happen to be contexts, units, facts, etc. In general, it would be nice if yaidom
would make it easy to support custom XML dialects. That is indeed the case. We already knew that yaidom is <em>extensible</em>, in that new element implementations offering the same
yaidom query API can easily be added. Yet, what's more, yaidom also facilitates a "yaidom querying experience" for <em>custom XML dialects</em>, such as XBRL instances (or DocBook files,
or Maven POM files, or XMPP message formats, or any other XML dialect described by schemas).</p>

<p>To that end, yaidom offers the <code>SubtypeAwareElemApi</code> query API trait. Whereas the <code>ElemApi</code> trait offers querying for child/descendant/descendant-or-self
elements, trait <code>SubtypeAwareElemApi</code> extends this to class hierarchies (for XML dialects), offering querying for child/descendant/descendant-or-self elements of specific
sub-types of the root class of the class hierarchy.</p>

<p>In <a href="http://dvreeze.github.io/code-snippets/xbrl-instances.html" target="_blank">this XBRL instance class hierarchy</a> we can see this action. Each part of an XBRL
instance is of type <code>XbrliElem</code> or a sub-type. Common sub-types are those for contexts, units, item facts, tuple facts, and, of course, XBRL instances themselves.
Super-type <code>XbrliElem</code> mixes in traits <code>ScopedElemApi</code> and <code>SubtypeAwareElemApi</code>. Trait <code>ScopedElemApi</code> offers the most common
yaidom element query API, as we know, and trait <code>SubtypeAwareElemApi</code> makes it easy to query for elements of specific types, with little boilerplate. The latter is used
internally in the code of the <code>XbrliElem</code> class hierarchy, but can also be used in client code, if need be.</p>

<p>For the remaining FRIS validations in this article, we will use the <code>XbrliElem</code> class hierarchy.</p>

<p>Consider FRIS rule 2.1.10. It states that there is a specific expected order of the child elements of the root element. One way to code that is as follows:</p>

<pre><code>// Assume xbrlInstance variable of type XbrlInstance

val remainingChildElems =
  xbrlInstance.findAllChildElems dropWhile {
    case e: SchemaRef => true
    case e => false
  } dropWhile {
    case e: LinkbaseRef => true
    case e => false
  } dropWhile {
    case e: RoleRef => true
    case e => false
  } dropWhile {
    case e: ArcroleRef => true
    case e => false
  } dropWhile {
    case e: XbrliContext => true
    case e => false
  } dropWhile {
    case e: XbrliUnit => true
    case e => false
  } dropWhile {
    case e: Fact => true
    case e => false
  } dropWhile {
    case e: FootnoteLink => true
    case e => false
  }

require(remainingChildElems.isEmpty)
</code></pre>

<p>Now consider FRIS rule 2.4.2 stating that all contexts must be used. It is also checked that all context references indeed refer to existing contexts.
Note in this case how friendly the XBRL instance model is compared to raw XML elements:</p>

<pre><code>val contextIds = xbrlInstance.allContextsById.keySet

val usedContextIds = xbrlInstance.findAllItems.map(_.contextRef).toSet

require(usedContextIds.subsetOf(contextIds))

// Oops, some contexts are not used, namely I-2004, D-2007-LI-ALL and I-2003
println(contextIds.diff(usedContextIds))
</code></pre>

<p>The next rule is more complex. FRIS rule 2.4.1 states that S-equal contexts should not occur. S-equality ("structural equality") is defined in the
Core XBRL specification. A good implementation of S-equality requires type information. Therefore Saxon-EE backed yaidom wrappers would be a good choice.
A very naive approximation is given below:</p>

<pre><code>def transformContextForSEqualityComparison(context: XbrliContext): resolved.Elem = {
  // Ignoring "normalization" of dates and QNames, as well as order of dimensions etc.
  val elem = context.indexedElem.elem.copy(attributes = Vector())
  resolved.Elem(elem).coalesceAndNormalizeAllText.removeAllInterElementWhitespace
}
</code></pre>

<p>Then rule 2.4.1 applied to our XBRL instance is as follows:</p>

<pre><code>val contextsBySEqualityGroup =
  xbrlInstance.allContexts.groupBy(e => transformContextForSEqualityComparison(e))

require(contextsBySEqualityGroup.size == xbrlInstance.allContexts.size)
</code></pre>

<p>As we can see, the more complex the rules, the more we profit from the fact that all code is Scala code, and that there is no needed effort in bridging
between Scala and XSLT, for example. The Scala language, its Collections API, and yaidom form a powerful combination.</p>

<p>Finally, consider FRIS rule 2.8.3, stating that concepts are either top-level or nested in tuples, but not both. Using the XBRL instance model, the code is simple:</p>

<pre><code>val topLevelConceptNames = xbrlInstance.allTopLevelFactsByEName.keySet

val nestedConceptNames =
  xbrlInstance.allTopLevelTuples.flatMap(_.findAllFacts).map(_.resolvedName).toSet

require(topLevelConceptNames.intersect(nestedConceptNames).isEmpty)
</code></pre>

<h3>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>In this article, the <em>yaidom Scala XML query library</em> was introduced. We used examples from XBRL and XMPP. It turned out that Scala, its Collections API, and the yaidom library form a powerful precise
XML processing "stack". This "stack" is even more powerful when using custom mature yaidom "backends" as Saxon-EE. It also turned out that yaidom makes it easy to support custom XML dialects (such as
XBRL instances), offering more type-safety and leading to less boilerplate. The <em>extensibility</em> of yaidom (in more than 1 way) is one of its strengths, along with its precise
<em>namespace support</em> and <em>uniform precise element query API</em> (offered by numerous <em>XML "backends"</em>).</p>

<p>The FRIS rule examples show that a programming language like Scala is a natural fit for implementing those rules. Had we used XSLT or XQuery instead, how would we easily have found unused
namespaces, for example? Moreover, how would we have supported custom XML dialects in the same way that yaidom facilitates such support?</p>

<p>The examples only used XMPP data and XBRL instances. These XBRL instances are described by XBRL taxonomies. Such taxonomies have to obey many rules as well. Taxonomies typically span many files, and their validation is usually much more complex than instance validation. The advantages of using a "Scala yaidom XML stack" would even be greater than for XBRL instances.</p>

<p>As a concluding remark, yaidom is used in production code developed at <a href="http://www.ebpi.nl" target="_blank">www.ebpi.nl</a>. Its usage in several projects has certainly helped it mature.
I want to thank my colleagues Jan-Paul van der Velden, Andrea Desole, Johan Walters and Nicholas Evans for their valuable feedback on earlier versions of yaidom.</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>

