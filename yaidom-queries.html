<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Yaidom queries by dvreeze</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Another Scala XML library</h1>
        <p>Yaidom is yet another Scala (immutable) DOM-like XML library.</p>


        <p class="view"><a href="https://github.com/dvreeze">View My GitHub Profile</a></p>

      </header>
      <section>
        <h3>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>This article is the first in a series of articles introducing a Scala DOM-like XML library, called <em>yaidom</em> ("yet another immutable DOM").</p>

<p>It is assumed that the reader knows the basics of XML, in particular XML namespaces. Some experience with XML processing in Java (e.g. JAXP) is also helpful. Finally, the reader is expected to have some familiarity with the Scala programming language, and with the Scala Collections API in particular.</p>

<p>This article only treats basic element querying in yaidom. The remainder of this article is organized as follows:</p>
<ol>
<li>Introductory example</li>
<li>Why yet another Scala XML library?</li>
<li>Introduction to yaidom element queries.</li>
<li>Uniform element query API.</li>
<li>Conclusion (of this first article about yaidom).</li>
</ol>

<p>The examples use the ubiquitous bookstore. The specific sample XML is from the (coursera) course Introduction to Databases, by Jennifer Widom (with permission).</p>

        <h3>
<a name="introductory-example" class="anchor" href="#introductory-example"><span class="octicon octicon-link"></span></a>Introductory example</h3>

<p>First we give an introductory example to querying in yaidom. Consider the following XML file: <a href="examples/books.xml" target="_blank">books.xml</a>. Suppose we have parsed this document, and that the parsed document has been stored into variable "doc". Then we can query for all book author last names as follows (without removing duplicates):</p>

<pre><code>for {
    bookElem <- doc.documentElement \ withLocalName("book")
    lastNameElem <- bookElem \\ withLocalName("Last_Name")
} yield lastNameElem.text
</code></pre>

<p>Unlike querying with the standard Scala XML library, we cannot chain "\" and "\\" operators. It will become clear in this article why yaidom sacrifices a little bit of conciseness compared to a more XPath-like experience.</p>

        <h3>
<a name="why-yet-another-scala-xml-library" class="anchor" href="#why-yet-another-scala-xml-library"><span class="octicon octicon-link"></span></a>Why yet another Scala XML library?</h3>

<p>XML processing in Java has never been easy. Direct use of SAX, DOM or StAX is low-level and cumbersome. Use of XPath may be low-level in the handling of returned DOM nodes or node lists, and performance issues quickly arise. Several other (DOM-like) libraries may improve on JAXP DOM, but still do not make XML processing significantly easier. The use of O-X mapping (such as JAXB) just for XML manipulation seems the wrong tool for the job, since that would turn an XML manipulation problem into a bigger O-X mapping problem between 2 different perspectives ("Java object" and "XML") that must be kept in sync. (I'm not criticizing O-X mapping, but I'm criticizing the use of O-X mapping if there is inherently no O-X mapping problem in the first place.)</p>

<p>Direct manipulation of XML should not be that hard. In Java (at least before version 8) not only XML processing, but data processing in general is hard (all the time explicitly iterating instead of just transforming collections). Scala and its expressive Collections API have a far more appealing data processing story, as most Scala programmers would agree. Shouldn't XML processing in Scala then be easier than in Java, as a consequence?</p>

<p>There are 3 Scala XML libraries that are currently often mentioned. There is Scales XML, which is not a DOM-like API. (It probably shines in "streaming scenarios".) Then there is Anti-XML, which seems abandoned, and which aimed to be an improvement on the third library, viz. the standard Scala XML library. Unfortunately, the standard Scala XML library has some (rather fundamental) issues that I find hard to accept. For example:</p>

<ul>
<li>Strange classes and class hierarchies, such as class Node indirectly extending Seq[Node], and class MetaData representing both an attribute and a linked list of attributes.</li>
<li>API inconsistencies, such methods "\" and "\\" offering namespace-aware attribute querying but only local-name-aware element querying.</li>
<li>Methods "\" and "\\" each meaning different things, depending on the string argument passed: element querying or attribute querying.</li>
<li>The library feeling outdated, and clearly predating Scala 2.8.</li>
</ul>

<p>Yes, I do realize that the standard XML library tried to offer an XPath-like experience. On the other hand, I do think that the question is fair how badly one should want to have an XPath-like experience (including concise chaining of operators), and what price one is willing to pay (in clarity, precision etc.). Anyway, a well-known critique of the Scala XML library (by the creator of Anti-XML) can be found <a href="http://www.codecommit.com/blog/scala/working-with-scalas-xml-support" target="_blank">here</a>.</p>

<p>It seems hard to find a Scala XML library having first-class namespace support. As an aside, the best explanation of XML namespaces that I have come across is <a href="http://www.lenzconsulting.com/namespaces/" target="_blank">Understanding XML Namespaces</a>. It distinguishes between <em>qualified names</em> (such as my:foo) and <em>expanded names</em> (such as {http://my}foo, in James Clark notation). Admittedly, qualified names occur in XML, and expanded names do not. Still, many XML libraries blur this fundamental distinction. Unfortunately, ignoring this distinction makes it hard to talk precisely about namespaces. In my view that leads to subpar namespace support. The quest for first-class namespace support was the most important reason to come up with <em>yaidom</em>.</p>

<p>Yaidom has been influenced by all of the 3 Scala XML libraries mentioned above, be it in very different ways. It has its own underlying design choices, however. In particular:</p>
<ul>
<li>It offers precise and clear support for XML namespaces.</li>
<li>It leverages Scala and its Collections API for their expressiveness. Nodes and collections of nodes are clearly distinguished. Hence, no XPath-like query support is offered, even if that means a little less conciseness.</li>
<li>It leverages Java (and JAXP in particular) to deal with the gory details of XML parsing and serialization, without trying to hide JAXP behind any leaky abstraction.</li>
<li>It has no single one-size-fits-all element representation, but offers multiple element implementations with different characteristics. These different element implementations still share the same yaidom element query API, to the extent possible.</li>
</ul>

<h3>
<a name="introduction-to-yaidom-element-queries" class="anchor" href="#introduction-to-yaidom-element-queries"><span class="octicon octicon-link"></span></a>Introduction to yaidom element queries</h3>

<p>All code examples below can be tried out in the Scala REPL (if the parent directory path of the example files is replaced). Scala 2.10.X is required, and yaidom 0.8.0 (or later) must be on the classpath.</p>

<p>Before showing some basic yaidom element queries, assume the following code to have executed:</p>

<pre><code>import java.io.File
import javax.xml.parsers._
import scala.collection.immutable
import eu.cdevreeze.yaidom._

val bookNamespace = "http://bookstore"

// Using a yaidom DocumentParser that used DOM internally
val docParser = parse.DocumentParserUsingDom.newInstance

// Replace the following path!
val parentDir = new File("path/to/parentdir")

val doc: Document =
    docParser.parse(new File(parentDir, "books.xml"))

val docElem = doc.documentElement
</code></pre>

<p>Here we instantiated a yaidom parser (using DOM internally), and parsed the XML file. The document element is stored in variable docElem, as "default" (immutable) yaidom element.</p>

<p>Let's get started with some basic yaidom element queries. The books.xml XML has some magazines and books. We can query for the magazines (as yaidom elements) as follows:</p>

<pre><code>val magazineElems =
    docElem.filterChildElems(e => e.localName == "Magazine")
</code></pre>

<p>In this query, we queried only for (some) <em>child elements</em> of the document element, knowing that all magazines are child elements of the document element. We also used no namespace in the query, knowing that in this case no ambiguity can arise. The query result (stripping some unused namespace declarations) consists of the following 4 XML elements:</p>

<pre><code>&lt;Magazine Month="January" Year="2009"&gt;
    &lt;Title&gt;National Geographic&lt;/Title&gt;
&lt;/Magazine&gt;

&lt;Magazine Month="Februari" Year="2009"&gt;
    &lt;Title&gt;National Geographic&lt;/Title&gt;
&lt;/Magazine&gt;

&lt;Magazine Month="Februari" Year="2009"&gt;
    &lt;Title&gt;Newsweek&lt;/Title&gt;
&lt;/Magazine&gt;

&lt;Magazine Month="March" Year="2009"&gt;
    &lt;Title&gt;Hector and Jeff's Database Hints&lt;/Title&gt;
&lt;/Magazine&gt;
</code></pre>

<p>Analogously, we can query for the 4 books (as yaidom elements) as follows:</p>

<pre><code>val bookElems =
    docElem.filterChildElems(e => e.localName == "Book")
</code></pre>

<p>Above, we queried for child elements with local name Book. We could have queried for all <em>descendant elements</em> with local name Book instead. Not surprisingly, the same elements would be returned:</p>

<pre><code>val bookElems =
    docElem.filterElems(e => e.localName == "Book")
</code></pre>

<p>We could also query for all <em>descendant-or-self elements</em> with local name Book. Again, the result would be the same:</p>

<pre><code>val bookElems =
    docElem.filterElemsOrSelf(e => e.localName == "Book")
</code></pre>

<p>Now we know how to query for child elements, descendant elements or descendant-or-self elements, given an element predicate. Instead of writing "filterChildElems" we can write "\", and instead of writing "filterElemsOrSelf" we can write "\\", however.  This would give us:</p>

<pre><code>val bookElems = docElem \ (e => e.localName == "Book")
</code></pre>

<p>and:</p>

<pre><code>val bookElems = docElem \\ (e => e.localName == "Book")
</code></pre>

<p>Most of yaidom's query API is easy to guess knowing the methods presented above. For example, method "findAllElems" returns all descendant elements (excluding self), and method "findAllElemsOrSelf" returns all descendant-or-self elements.</p>

<h3>
<a name="uniform-element-query-api" class="anchor" href="#uniform-element-query-api"><span class="octicon octicon-link"></span></a>Uniform element query API</h3>

<h4>
<a name="elemapi-trait" class="anchor" href="#elemapi-trait"><span class="octicon octicon-link"></span></a>ElemApi trait</h4>

<p>Above, we introduced basic element querying in yaidom, using the "standard" element implementation. Yaidom does not conform to the view that there is a one-size-fits-all element implementation, as we will see. Fortunately, this does not mean that there are as many yaidom element query APIs as there are element implementations. On the contrary, most element implementations mix in the ElemApi trait, which is the most important part of the query API.</p>

<p>The yaidom element query API plays very well with the Scala Collections API. Typical non-trivial queries are written as for-expressions, combining Scala collections with yaidom query API methods. In a sense, the yaidom element query API is a <em>uniform</em> element query API, and the Scala Collections API plays the role of <em>universal</em> (collection) query API.</p>

<p>Below we show yaidom as uniform query API. Again start with the same document used above. The item declarations (which are top-level element declarations with the xbrli:item substitution group) in the schema document can be found uniformly across element implementations as follows:</p>

<pre><code>def findAllItemDeclarations[E <: ElemApi[E]](docElem: E): immutable.IndexedSeq[E] = {
    import ElemApi._
    for {
        elemDecl <- docElem \ withEName(xsNamespace, "element")
        if (elemDecl \@ EName("substitutionGroup")) == Some("xbrli:item")
    } yield elemDecl
}
</code></pre>

<p>Typical yaidom client code does not abstract over multiple element implementations, but generics are used here to show that the exact same query API works for multiple element implementations. In the function signature above, "E" is the type of the element implementation itself. We imported all members of the ElemApi companion object, to have the "withEName" element predicate builder in scope. Note that the query is not very robust, because it filters substitution groups on the qualified name, and not on the expanded name. We'll fix that later, paying the price of losing genericity.</p>

<h4>
<a name="default-yaidom-elements" class="anchor" href="#default-yaidom-elements"><span class="octicon octicon-link"></span></a>"Default" yaidom elements</h4>

<p>Given the schema document above, we can query the item declarations as follows:</p>

<pre><code>val itemDecls =
    findAllItemDeclarations(schemaDoc.documentElement)
</code></pre>

<p>The query result (again stripping unused namespace declarations) consists of the following XML elements:</p>

<pre><code>&lt;element type="xbrli:monetaryItemType" name="Land" substitutionGroup="xbrli:item" xbrli:periodType="instant" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns="http://www.w3.org/2001/XMLSchema"/&gt;

&lt;element type="xbrli:monetaryItemType" name="BuildingsNet" substitutionGroup="xbrli:item" xbrli:periodType="instant" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns="http://www.w3.org/2001/XMLSchema"/&gt;

&lt;element type="xbrli:monetaryItemType" name="FurnitureAndFixturesNet" substitutionGroup="xbrli:item" xbrli:periodType="instant" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns="http://www.w3.org/2001/XMLSchema"/&gt;

&lt;element type="xbrli:monetaryItemType" name="ComputerEquipmentNet" substitutionGroup="xbrli:item" xbrli:periodType="instant" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns="http://www.w3.org/2001/XMLSchema"/&gt;

&lt;element type="xbrli:monetaryItemType" name="OtherPropertyPlantAndEquipmentNet" substitutionGroup="xbrli:item" xbrli:periodType="instant" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns="http://www.w3.org/2001/XMLSchema"/&gt;

&lt;element type="xbrli:monetaryItemType" name="PropertyPlantAndEquipmentNet" substitutionGroup="xbrli:item" xbrli:periodType="instant" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns="http://www.w3.org/2001/XMLSchema"/&gt;
</code></pre>

<p>We can now check if all facts in the XBRL instance correspond to item declarations in the schema document as follows:</p>

<pre><code>val tns =
    schemaDoc.documentElement.attribute(EName("targetNamespace"))

val itemDeclsByTargetENames: Map[EName, Elem] = {
    val result = itemDecls map { e =>
        val name = e.attribute(EName("name"))
        EName(tns, name) -> e
    }
    result.toMap
}

val factElems = instanceDoc.documentElement \ { e =>
    e.resolvedName.namespaceUriOption == Some(helloWorldNamespace)
}

require(factElems.map(e => e.resolvedName).toSet.subsetOf(
    itemDeclsByTargetENames.keySet))
</code></pre>

<p>Prefixes are insignificant in XML. Consider schema file <a href="examples/HelloWorld2.xsd" target="_blank">HelloWorld2.xml</a>, which is equivalent to HelloWorld.xml, except that the default namespace has been replaced by prefix "xs":<p>

<pre><code>val schemaDoc2: Document =
    docParser.parse(new File(parentDir, "HelloWorld2.xsd"))
</code></pre>

<p>How can we easily assert that these documents are equivalent XML documents? To that end, yaidom offers so-called "resolved" elements, which contain only expanded (element and attribute) names, and no qualified names. Indeed:</p>

<pre><code>val rootElem = schemaDoc.documentElement
val rootElem2 = schemaDoc2.documentElement

// Method removeAllInterElementWhitespace makes the equality comparison
// more robust, because it removes whitespace used for formatting

require(resolved.Elem(rootElem).removeAllInterElementWhitespace ==
    resolved.Elem(rootElem2).removeAllInterElementWhitespace)
</code></pre>

<h4>
<a name="resolved-elements" class="anchor" href="#resolved-elements"><span class="octicon octicon-link"></span></a>"Resolved" elements</h4>

<p>To show that the yaidom query API is uniform, let's now query the schema document element as "resolved" element for its item declarations:</p>

<pre><code>val resolvedSchemaDocElem =
    resolved.Elem(schemaDoc.documentElement)

val resolvedItemDecls =
    findAllItemDeclarations(resolvedSchemaDocElem)
</code></pre>

<h4>
<a name="dom-wrapper-elements" class="anchor" href="#dom-wrapper-elements"><span class="octicon octicon-link"></span></a>"DOM wrapper" elements</h4>

<p>Sometimes we have a (mutable) JAXP DOM tree, and do not want to convert it to a yaidom immutable Elem tree. We can still use the yaidom query API to query those DOM elements. Function "findAllItemDeclarations" can still be called:</p>

<pre><code>// Using a JAXP (DOM) DocumentBuilderFactory
val dbf = DocumentBuilderFactory.newInstance
val db = dbf.newDocumentBuilder
val d = db.parse(new File(parentDir, "HelloWorld.xsd"))

val wrapperDoc = dom.DomDocument(d)

val domItemDecls =
    findAllItemDeclarations(wrapperDoc.documentElement)
</code></pre>

<h4>
<a name="indexed-elements" class="anchor" href="#indexed-elements"><span class="octicon octicon-link"></span></a>"Indexed" elements</h4>

<p>Sometimes we want to use immutable elements, and still have access to the ancestry of each element. For example, when querying for item declarations, we need to inspect the document element for the target namespace. With so-called "indexed" elements, each element has indeed access to its ancestry.</p>

<p>This time using "indexed" elements, we again query for item declarations, but here we need no separate query for the target namespace:</p>

<pre><code>val indexedSchemaDoc = indexed.Document(schemaDoc)

val indexedItemDecls =
    findAllItemDeclarations(indexedSchemaDoc.documentElement)

val targetENames: Set[EName] =
    (indexedItemDecls map { e =>
        val tnsOption = e.rootElem \@ EName("targetNamespace")
        val name = e.attribute(EName("name"))
        EName(tnsOption, name)
    }).toSet

require(
    factElems.map(e => e.resolvedName).toSet.subsetOf(targetENames))
</code></pre>

<h4>
<a name="uniform-query-api-wrap-up" class="anchor" href="#uniform-query-api-wrap-up"><span class="octicon octicon-link"></span></a>Uniform query API wrap up</h4>

<p>There are more element implementations offering the same query API, such as wrappers for Scala XML Elems. Yaidom is extensible in this regard, since more element implementations can easily be created by mixing in some yaidom traits like ElemLike, and by implementing the methods that are abstract in those traits.</p>

<p>It was promised earlier to come up with a more robust "findAllItemDeclarations" method. This one only works for the "default" yaidom element implementation:</p>

<pre><code>def findAllItemDeclarations(docElem: Elem): immutable.IndexedSeq[Elem] = {
    import ElemApi._
    for {
        elemDecl <- docElem \ withEName(xsNamespace, "element")
        if elemDecl.attributeAsResolvedQNameOption(EName("substitutionGroup")) ==
            Some(EName(xbrliNamespace, "item"))
    } yield elemDecl
}
</code></pre>

<h3>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>In this article a case was made for yet another Scala XML library, called yaidom. Its precise support for XML namespaces may be its strongest asset. The API plays very well with the Scala Collections API, and it trades a little bit of conciseness for clarity and precision.</p>

<p>The basics of querying in yaidom were explained in this article. The examples used are XBRL examples originating from <a href="http://xbrl.squarespace.com/" target="_blank">xbrl.squarespace.com</a>.</p>

<p>Succeeding articles on yaidom will treat more advanced querying, functional updates, and configuration of yaidom.</p>

<p>As a concluding remark, yaidom is used in production code developed at <a href="http://www.ebpi.nl" target="_blank">www.ebpi.nl</a>. Its usage in several projects has certainly helped it mature. I want to thank my colleagues Jan-Paul van der Velden, Andrea Desole, Johan Walters and Nicholas Evans for their valuable feedback on earlier versions of yaidom.</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
