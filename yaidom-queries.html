<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Yaidom queries by dvreeze</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Another Scala XML library</h1>
        <p>Yaidom is yet another Scala (immutable) DOM-like XML library.</p>


        <p class="view"><a href="https://github.com/dvreeze">View My GitHub Profile</a></p>

      </header>
      <section>
        <h3>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>This article is the first in a series of articles introducing a Scala DOM-like XML library, called <em>yaidom</em> ("yet another immutable DOM").</p>

<p>It is assumed that the reader knows the basics of XML, in particular XML namespaces. Preferably the reader knows a little bit about XML Schema as well, to make sense of the examples. Some experience with XML processing in Java (e.g. JAXP) is also helpful. Finally, the reader is expected to have some familiarity with the Scala programming language, and with the Scala Collections API in particular.</p>

<p>This article only treats basic element querying in yaidom. The remainder of this article is organized as follows:</p>
<ol>
<li>Why yet another Scala XML library?</li>
<li>Using XBRL examples. (See below.)</li>
<li>Introduction to yaidom element queries.</li>
<li>Uniform element query API.</li>
<li>Conclusion (of this first article about yaidom).</li>
</ol>

<p>Although the examples use XBRL (which stands for eXtensible Business Reporting Language), no prior XBRL knowledge is assumed on the part of the reader. With only a minimal explanation the examples are quite easy to understand.</p>

        <h3>
<a name="why-yet-another-scala-xml-library" class="anchor" href="#why-yet-another-scala-xml-library"><span class="octicon octicon-link"></span></a>Why yet another Scala XML library?</h3>

<p>XML processing in Java has never been easy. Direct use of SAX, DOM or StAX is low-level and cumbersome. Use of XPath may be low-level in the handling of returned DOM nodes or node lists, and performance issues quickly arise. Several other (DOM-like) libraries may improve on JAXP DOM, but still do not make XML processing significantly easier. The use of O-X mapping (such as JAXB) just for XML manipulation seems the wrong tool for the job, since that would turn an XML manipulation problem into a bigger O-X mapping problem between 2 different perspectives ("Java object" and "XML") that must be kept in sync. (I'm not criticizing O-X mapping, but I'm criticizing the use of O-X mapping if there is inherently no O-X mapping problem in the first place.)</p>

<p>Direct manipulation of XML should not be that hard. In Java (at least before version 8) not only XML processing, but data processing in general is hard (all the time explicitly iterating instead of just transforming collections). Scala and its expressive Collections API have a far more appealing data processing story, as most Scala programmers would agree. Shouldn't XML processing in Scala then be easier than in Java, as a consequence?</p>

<p>There are 3 Scala XML libraries that are currently often mentioned. There is Scales XML, which is not a DOM-like API. (It probably shines in "streaming scenarios".) Then there is Anti-XML, which seems abandoned, and which aimed to be an improvement on the third library, viz. the standard Scala XML library. Unfortunately, the standard Scala XML library has some (rather fundamental) issues that I find hard to accept. For example:</p>

<ul>
<li>Strange classes and class hierarchies, such as class Node indirectly extending Seq[Node], and class MetaData representing both an attribute and a linked list of attributes.</li>
<li>API inconsistencies, such methods "\" and "\\" offering namespace-aware attribute querying but only local-name-aware element querying.</li>
<li>Methods "\" and "\\" each meaning different things, depending on the string argument passed: element querying or attribute querying.</li>
<li>The library feeling outdated, and clearly predating Scala 2.8.</li>
</ul>

<p>Yes, I do realize that the standard XML library tried to offer an XPath-like experience. On the other hand, I do think that the question is fair how badly one should want to have an XPath-like experience (including concise chaining of operators), and what price one is willing to pay (in clarity, precision etc.). Anyway, a well-known critique of the Scala XML library (by the creator of Anti-XML) can be found <a href="http://www.codecommit.com/blog/scala/working-with-scalas-xml-support">here</a>.</p>

<p>It seems hard to find a Scala XML library having first-class namespace support. As an aside, the best explanation of XML namespaces that I have come across is <a href="http://www.lenzconsulting.com/namespaces/">Understanding XML Namespaces</a>. It distinguishes between <em>qualified names</em> (such as my:foo) and <em>expanded names</em> (such as {http://my}foo, in James Clark notation). Admittedly, qualified names occur in XML, and expanded names do not. Still, many XML libraries blur this fundamental distinction. Unfortunately, ignoring this distinction makes it hard to talk precisely about namespaces. In my view that leads to subpar namespace support. The quest for first-class namespace support was the most important reason to come up with <em>yaidom</em>.</p>

<p>Yaidom has been influenced by all of the 3 Scala XML libraries mentioned above, be it in very different ways. It has its own underlying design choices, however. The core design principles behind yaidom are:</p>
<ul>
<li>It offers precise and clear support for XML namespaces.</li>
<li>It leverages Scala and its Collections API for their expressiveness. No XPath-like query support is offered, even if that means a little less conciseness.</li>
<li>It leverages Java (and JAXP in particular) to deal with the gory details of XML parsing and serialization, without trying to hide JAXP behind any leaky abstraction.</li>
<li>It has no single one-size-fits-all element representation, but offers multiple element implementations with different characteristics. These different element implementations still share the same yaidom element query API, to the extent possible.</li>
</ul>

<h3>
<a name="using-xbrl-examples" class="anchor" href="#using-xbrl-examples"><span class="octicon octicon-link"></span></a>Using XBRL examples</h3>

<p>To illustrate yaidom, we use examples in the domain of XBRL.</p>

<h3>
<a name="introduction-to-yaidom-element-queries" class="anchor" href="#introduction-to-yaidom-element-queries"><span class="octicon octicon-link"></span></a>Introduction to yaidom element queries</h3>

<p>Before showing some basic yaidom element queries, assume the following code to have executed:</p>

<pre><code>import java.io.File
import javax.xml.parsers._
import scala.collection.immutable
import eu.cdevreeze.yaidom._

val xsNamespace = "http://www.w3.org/2001/XMLSchema"
val xbrliNamespace = "http://www.xbrl.org/2003/instance"
val helloWorldNamespace = "http://xbrl.squarespace.com/HelloWorld"

// Using a yaidom DocumentParser that used DOM internally
val docParser = parse.DocumentParserUsingDom.newInstance

val instanceDoc: Document =
    docParser.parse(new File("/path/to/HelloWorld.xml"))
val schemaDoc: Document =
    docParser.parse(new File("/path/to/HelloWorld.xsd"))

val instanceDocElem = instanceDoc.documentElement
val schemaDocElem = schemaDoc.documentElement
</code></pre>

<p>Let's get started with some basic yaidom element queries. The HelloWorld.xml XBRL instance has some units, contexts and (top-level) facts. We can query for the units (as yaidom elements) as follows:</p>

<pre><code>val unitElems =
    instanceDocElem.filterChildElems(e => e.localName == "unit")
</code></pre>

<p>In this query, we queried only for (some) <em>child elements</em> of the document element, knowing that the single unit is a child element of the document element. We also used no namespace in the query, knowing that in this case no fact has the (local) name unit, be it in another namespace.</p>

<p>Analogously, we can query for the (2) contexts (as yaidom elements) as follows:</p>

<pre><code>val contextElems =
    instanceDocElem.filterChildElems(e => e.localName == "context")
</code></pre>

<p>Above, we queried for child elements with local name context. We could have queried for all <em>descendant elements</em> with local name context instead. Not surprisingly, the same elements would be returned:</p>

<pre><code>val contextElems =
    instanceDocElem.filterElems(e => e.localName == "context")
</code></pre>

<p>We could also query for all <em>descendant-or-self elements</em> with local name context. Again, the result would be the same:</p>

<pre><code>val contextElems =
    instanceDocElem.filterElemsOrSelf(e => e.localName == "context")
</code></pre>

<p>Now we know how to query for child elements, descendant elements or descendant-or-self elements, given an element predicate. Instead of writing "filterChildElems" we can write "\", and instead of writing "filterElemsOrSelf" we can write "\\", however.  This would give us:</p>

<pre><code>val contextElems = instanceDocElem \ (e => e.localName == "context")
</code></pre>

<p>and:</p>

<pre><code>val contextElems = instanceDocElem \\ (e => e.localName == "context")
</code></pre>

<p>Let's now query for the 12 top-level facts, knowing that their element names are in the namespace "http://xbrl.squarespace.com/HelloWorld":</p>

<pre><code>val factElems = instanceDocElem filterChildElems { e =>
    e.resolvedName.namespaceUriOption == Some(helloWorldNamespace)
}
</code></pre>

<p>Most of yaidom's query API is easy to guess knowing the methods presented above. For example, method "findAllElems" returns all descendant elements (excluding self), and method "findAllElemsOrSelf" returns all descendant-or-self elements.</p>

<h3>
<a name="uniform-element-query-api" class="anchor" href="#uniform-element-query-api"><span class="octicon octicon-link"></span></a>Uniform element query API</h3>

<p>Above, we introduced basic element querying in yaidom, using the "standard" element implementation. Yaidom does not conform to the view that there is a one-size-fits-all element implementation, as we will see. Fortunately, this does not mean that there are as many yaidom element query APIs as there are element implementations. On the contrary, most element implementations mix in the ElemApi trait, which is the most important part of the query API.</p>

<p>The yaidom element query API plays very well with the Scala Collections API. Typical non-trivial queries are written as for-expressions, combining Scala collections with yaidom query API methods. In a sense, the yaidom element query API is a <em>uniform</em> element query API, and the Scala Collections API plays the role of <em>universal</em> (collection) query API.</p>

<p>Below we show yaidom as uniform query API. Again start with the same documents used above. The item declarations (which are top-level element declarations with the xbrli:item substitution group) in the schema document can be found uniformly across element implementations as follows:</p>

<pre><code>def findAllItemDeclarations[E <: ElemApi[E]](docElem: E): immutable.IndexedSeq[E] = {
    import ElemApi._
    for {
        elemDecl <- docElem \ withEName(xsNamespace, "element")
        if (elemDecl \@ EName("substitutionGroup")) == Some("xbrli:item")
    } yield elemDecl
}
</code></pre>

<p>Typical yaidom client code does not abstract over multiple element implementations, but generics are used here to show that the exact same query API works for multiple element implementations. In the function signature above, "E" is the type of the element implementation itself. We imported all members of the ElemApi companion object, to have the "withEName" element predicate builder in scope. Note that the query is not very robust, because it filters substitution groups on the qualified name, and not on the expanded name. We'll fix that later, paying the price of losing genericity.</p>

<p>Given the schema document above, we can query the item declarations as follows:</p>

<pre><code>val itemDecls =
    findAllItemDeclarations(schemaDoc.documentElement)
</code></pre>

<p>We can now check if all facts in the XBRL instance correspond to item declarations in the schema document as follows:</p>

<pre><code>val tns =
    schemaDoc.documentElement.attribute(EName("targetNamespace"))

val itemDeclsByTargetENames: Map[EName, Elem] = {
    itemDecls.map(e => (EName(tns, e.attribute(EName("name"))) -> e)).toMap
}

val factElems = instanceDoc.documentElement \ { e =>
    e.resolvedName.namespaceUriOption == Some(helloWorldNamespace)
}

require(factElems.map(e => e.resolvedName).toSet.subsetOf(
    itemDeclsByTargetENames.keySet))
</code></pre>

<p>Prefixes are insignificant in XML. Let HelloWorld2.xml be equivalent to HelloWorld.xml, except that the default namespace has been replaced by prefix "xs":<p>

<pre><code>val schemaDoc2: Document =
    docParser.parse(new File("/path/to/HelloWorld2.xsd"))
</code></pre>

<p>How can we easily assert that these documents are equivalent XML documents? To that end, yaidom offers so-called "resolved" elements, which contain only expanded (element and attribute) names, and no qualified names. Indeed:</p>

<pre><code>val rootElem = schemaDoc.documentElement
val rootElem2 = schemaDoc2.documentElement

require(resolved.Elem(rootElem).removeAllInterElementWhitespace ==
    resolved.Elem(rootElem2).removeAllInterElementWhitespace)
</code></pre>

<p>To show that the yaidom query API is uniform, let's now query the schema document element as "resolved" element for its item declarations:</p>

<pre><code>val resolvedSchemaDocElem =
    resolved.Elem(schemaDoc.documentElement)

val resolvedItemDecls =
    findAllItemDeclarations(resolvedSchemaDocElem)
</code></pre>

<p>Sometimes we have a (mutable) JAXP DOM tree, and do not want to convert it to a yaidom immutable Elem tree. We can still use the yaidom query API to query those DOM elements. Function "findAllItemDeclarations" can still be called:</p>

<pre><code>val dbf = DocumentBuilderFactory.newInstance
val db = dbf.newDocumentBuilder
val d = db.parse(new File("/path/to/HelloWorld.xsd"))

val wrapperDoc = dom.DomDocument(d)

val domItemDecls =
    findAllItemDeclarations(wrapperDoc.documentElement)
</code></pre>

<p>Sometimes we want to use immutable elements, and still have access to the ancestry of each element. For example, when querying for item declarations, we need to inspect the document element for the target namespace. With so-called "indexed" elements, each element has indeed access to its ancestry.</p>

<p>This time using "indexed" elements, we again query for item declarations, but this time we need no separate query for the target namespace:</p>

<pre><code>val indexedSchemaDoc = indexed.Document(schemaDoc)

val indexedItemDecls =
    findAllItemDeclarations(indexedSchemaDoc.documentElement)

val targetENames: Set[EName] =
    (indexedItemDecls map { e =>
        val tnsOption = e.rootElem \@ EName("targetNamespace")
        val name = e.attribute(EName("name"))
        EName(tnsOption, name)
    }).toSet

require(
    factElems.map(e => e.resolvedName).toSet.subsetOf(targetENames))
</code></pre>

<p>There are more element implementations offering the same query API, such as wrappers for Scala XML Elems. Yaidom is extensible in this regard, since more element implementations can easily be created by mixing in some yaidom traits like ElemApi, and by implementing the methods that are abstract in those traits.</p>

<p>It was promised earlier to come up with a more robust "findAllItemDeclarations" method. This one only works for the "default" yaidom element implementation:</p>

<pre><code>def findAllItemDeclarations(docElem: Elem): immutable.IndexedSeq[Elem] = {
    import ElemApi._
    for {
        elemDecl <- docElem \ withEName(xsNamespace, "element")
        if elemDecl.attributeAsResolvedQNameOption(EName("substitutionGroup")) ==
            Some(EName(xbrliNamespace, "item"))
    } yield elemDecl
}
</code></pre>
<h3>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>... conclusion ...</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
