<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Yaidom queries by dvreeze</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Another Scala XML library</h1>
        <p>Yaidom is yet another Scala (immutable) DOM-like XML library.</p>


        <p class="view"><a href="https://github.com/dvreeze">View My GitHub Profile</a></p>

      </header>
      <section>
        <h3>
<a name="why-yet-another-scala-xml-library" class="anchor" href="#why-yet-another-scala-xml-library"><span class="octicon octicon-link"></span></a>Why yet another Scala XML library?</h3>

<p>XML processing in Java has never been easy. Arguably, the simplest way to manipulate XML in Java is through XML data binding solutions, such as JAXB. Such solutions try to hide the XML, making the XML look like normal Java objects. In non-trivial mapping scenarios one easily ends up having to keep 2 perspectives on the same XML data in sync: the "Java object view" and the "XML view".</p>

<p>Hence, O-X mapping may not be the best answer to XML processing. On the other hand, directly manipulating XML should not be that hard in the first place.</p>

<p>Scala could help make direct XML manipulation easy, by leveraging the Scala Collections API. The standard Scala XML API should have been the obvious choice. It predates Scala 2.8, however, and its namespace support is not as precise and clear as I would like it to be. Anti-XML aimed at being a better alternative, but that project seems abandoned. The third well-known Scala XML library is Scales XML, but this is not a DOM-like API.</p>

<p>It seems hard to find a Scala XML library having first-class namespace support, and offering precise and clear namespace handling. The best explanation of XML namespaces that I have come across is <a href="http://www.lenzconsulting.com/namespaces/">Understanding XML Namespaces</a>. It distinguishes between qualified names (such as my:foo) and expanded names (such as {http://my}foo, in James Clark notation). Many XML libraries blur this distinction, and therefore offer sub-par namespace support.</p>

<p>This was the most important reason to come up with an alternative Scala XML DOM-like library, called <em>yaidom</em>.</p>

<p>This is the first in a series of articles about yaidom. It introduces basic XML querying in yaidom.</p>

<h3>
<a name="using-xbrl-examples" class="anchor" href="#using-xbrl-examples"><span class="octicon octicon-link"></span></a>Using XBRL examples</h3>

<p>To illustrate yaidom, we use examples in the domain of XBRL.</p>

<h3>
<a name="introduction-to-yaidom-element-queries" class="anchor" href="#introduction-to-yaidom-element-queries"><span class="octicon octicon-link"></span></a>Introduction to yaidom element queries</h3>

<p>Let's get started with some basic yaidom element queries. The HelloWorld.xml XBRL instance has some units, contexts and (top-level) facts. We can query for the units (as yaidom elements) as follows:</p>

<pre><code>val unitElems = doc.documentElement.filterChildElems(e => e.localName == "unit")
</code></pre>

<p>In this query, we queried only for (some) <em>child elements</em> of the document element, knowing that the single unit is a child element of the document element. We also used no namespace in the query, knowing that in this case no fact has the (local) name unit, but then in another namespace.</p>

<p>Analogously, we can query for the (2) contexts (as yaidom elements) as follows:</p>

<pre><code>val contextElems = doc.documentElement.filterChildElems(e => e.localName == "context")
</code></pre>

<p>Above, we queried for child elements with local name context. We could have queried for all <em>descendant elements</em> with local name context instead. Not surprisingly, the same elements would be returned:</p>

<pre><code>val contextElems = doc.documentElement.filterElems(e => e.localName == "context")
</code></pre>

<p>We could also query for all <em>descendant-or-self elements</em> with local name context. Again, the result would be the same:</p>

<pre><code>val contextElems = doc.documentElement.filterElemsOrSelf(e => e.localName == "context")
</code></pre>

<p>Now we know how to query for child elements, descendant elements or descendant-or-self elements, given an element predicate. Instead of writing "filterChildElems" we can write "\", and instead of writing "filterElemsOrSelf" we can write "\\", however.  This would give us:</p>

<pre><code>val contextElems = doc.documentElement \ (e => e.localName == "context")
</code></pre>

<pre><code>val contextElems = doc.documentElement \\ (e => e.localName == "context")
</code></pre>

<p>Let's query for the 12 top-level facts, knowing that their element names are in the namespace "http://xbrl.squarespace.com/HelloWorld":</p>

<pre><code>val factElems = doc.documentElement filterChildElems { e =>
  e.resolvedName.namespaceUriOption == Some(helloWorldNamespace)
}
</code></pre>

<h3>
<a name="uniform-element-query-api" class="anchor" href="#uniform-element-query-api"><span class="octicon octicon-link"></span></a>Uniform element query API</h3>

<p>... the content of this section ...</p>

<h3>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>... conclusion ...</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
