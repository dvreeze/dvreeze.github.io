<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Yaidom queries by dvreeze</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Another Scala XML library</h1>
        <p>Yaidom is yet another Scala (immutable) DOM-like XML library.</p>


        <p class="view"><a href="https://github.com/dvreeze">View My GitHub Profile</a></p>

      </header>
      <section>
        <h3>
<a name="why-yet-another-scala-xml-library" class="anchor" href="#why-yet-another-scala-xml-library"><span class="octicon octicon-link"></span></a>Why yet another Scala XML library?</h3>

<p>XML processing in Java has never been easy. Arguably, the simplest way to manipulate XML in Java is through XML data binding solutions, such as JAXB. Such solutions try to hide the XML, making the XML look like normal Java objects. Unfortunately, in non-trivial mapping scenarios one easily ends up having to keep 2 perspectives on the same XML data in sync: the "Java object view" and the "XML view".</p>

<p>Hence, O-X mapping may not be the best answer to XML processing. On the other hand, directly manipulating XML should not have been that hard in the first place.</p>

<p>Scala could help make direct XML manipulation easy, by leveraging the Scala Collections API. The standard Scala XML API should have been the obvious choice. It predates Scala 2.8, however, and its namespace support is not as precise and clear as I would like it to be. Anti-XML aimed at being a better alternative, but that project seems abandoned. The third well-known Scala XML library is Scales XML, but this is not a DOM-like API.</p>

<p>It seems hard to find a Scala XML library having first-class namespace support, and offering precise and clear namespace handling. The best explanation of XML namespaces that I have come across is <a href="http://www.lenzconsulting.com/namespaces/">Understanding XML Namespaces</a>. It distinguishes between <em>qualified names</em> (such as my:foo) and <em>expanded names</em> (such as {http://my}foo, in James Clark notation). Many XML libraries blur this distinction, and therefore offer sub-par namespace support.</p>

<p>This was the most important reason to come up with an alternative Scala XML DOM-like library, called <em>yaidom</em>.</p>

<p>This is the first in a series of articles about yaidom. It introduces basic XML querying in yaidom.</p>

<h3>
<a name="using-xbrl-examples" class="anchor" href="#using-xbrl-examples"><span class="octicon octicon-link"></span></a>Using XBRL examples</h3>

<p>To illustrate yaidom, we use examples in the domain of XBRL.</p>

<h3>
<a name="introduction-to-yaidom-element-queries" class="anchor" href="#introduction-to-yaidom-element-queries"><span class="octicon octicon-link"></span></a>Introduction to yaidom element queries</h3>

<p>Before showing some basic yaidom element queries, assume the following code to have executed:</p>

<pre><code>import java.io.File
import javax.xml.parsers._
import scala.collection.immutable
import eu.cdevreeze.yaidom._

val xsNamespace = "http://www.w3.org/2001/XMLSchema"
val xbrliNamespace = "http://www.xbrl.org/2003/instance"
val helloWorldNamespace = "http://xbrl.squarespace.com/HelloWorld"

val docParser = parse.DocumentParserUsingDom.newInstance

val instanceDoc: Document = docParser.parse(new File("/path/to/HelloWorld.xml"))
val schemaDoc: Document = docParser.parse(new File("/path/to/HelloWorld.xsd"))
</code></pre>

<p>Let's get started with some basic yaidom element queries. The HelloWorld.xml XBRL instance has some units, contexts and (top-level) facts. We can query for the units (as yaidom elements) as follows:</p>

<pre><code>val unitElems = instanceDoc.documentElement.filterChildElems(e => e.localName == "unit")
</code></pre>

<p>In this query, we queried only for (some) <em>child elements</em> of the document element, knowing that the single unit is a child element of the document element. We also used no namespace in the query, knowing that in this case no fact has the (local) name unit, but then in another namespace.</p>

<p>Analogously, we can query for the (2) contexts (as yaidom elements) as follows:</p>

<pre><code>val contextElems =
    instanceDoc.documentElement.filterChildElems(e => e.localName == "context")
</code></pre>

<p>Above, we queried for child elements with local name context. We could have queried for all <em>descendant elements</em> with local name context instead. Not surprisingly, the same elements would be returned:</p>

<pre><code>val contextElems =
    instanceDoc.documentElement.filterElems(e => e.localName == "context")
</code></pre>

<p>We could also query for all <em>descendant-or-self elements</em> with local name context. Again, the result would be the same:</p>

<pre><code>val contextElems =
    instanceDoc.documentElement.filterElemsOrSelf(e => e.localName == "context")
</code></pre>

<p>Now we know how to query for child elements, descendant elements or descendant-or-self elements, given an element predicate. Instead of writing "filterChildElems" we can write "\", and instead of writing "filterElemsOrSelf" we can write "\\", however.  This would give us:</p>

<pre><code>val contextElems = instanceDoc.documentElement \ (e => e.localName == "context")
</code></pre>

<pre><code>val contextElems = instanceDoc.documentElement \\ (e => e.localName == "context")
</code></pre>

<p>Let's query for the 12 top-level facts, knowing that their element names are in the namespace "http://xbrl.squarespace.com/HelloWorld":</p>

<pre><code>val factElems = instanceDoc.documentElement filterChildElems { e =>
    e.resolvedName.namespaceUriOption == Some(helloWorldNamespace)
}
</code></pre>

<h3>
<a name="uniform-element-query-api" class="anchor" href="#uniform-element-query-api"><span class="octicon octicon-link"></span></a>Uniform element query API</h3>

<p>Above, we introduced basic element querying in yaidom, using the "standard" element implementation. Yaidom does not conform to the view that there is a one-size-fits-all element implementation, as we will see. Fortunately, this does not mean that there are as many yaidom element query APIs as there are element implementations. On the contrary, most element implementations mix in the ElemApi trait, which is the most important part of the query API.</p>

<p>The yaidom element query API plays very well with the Scala Collections API. The yaidom query API only turns elements into collections of elements, and the Scala Collections API can be used seamlessly to manipulate those collections of elements. Put differently, the yaidom element query API is a <em>uniform</em> element query API, and the Scala Collections API plays the role of <em>universal</em> query API.</p>

<p>Below we show yaidom as uniform query API. Again start with the following same documents used above. The item declarations (which are top-level element declarations with the xbrli:item substitution group) in the schema document can be found uniformly across element implementations as follows:</p>

<pre><code>def findAllItemDeclarations[E <: ElemApi[E]](docElem: E): immutable.IndexedSeq[E] = {
    import ElemApi._
    for {
        elemDecl <- docElem \ withEName(xsNamespace, "element")
        if (elemDecl \@ EName("substitutionGroup")) == Some("xbrli:item")
    } yield elemDecl
}
</code></pre>

<p>Typical yaidom client code does not abstract over multiple element implementations, but it is done here to show that the exact same query API works for multiple element implementations. In the function signature above, "E" is the type of the element implementation itself. We imported all members of the ElemApi companion object, to have the "withEName" element predicate builder in scope. Note that the query is not very robust, because it filters substitution groups on the qualified name, and not on the expanded name. We'll fix that later, with loss of genericity.</p>

<p>Given the schema document above, we can query the item declarations as follows:</p>

<pre><code>val itemDecls = findAllItemDeclarations(schemaDoc.documentElement)
</code></pre>

<p>We can now check if all facts in the XBRL instance correspond to item declarations in the schema document as follows:</p>

<pre><code>val tns = schemaDoc.documentElement.attribute(EName("targetNamespace"))

val itemDeclsByTargetENames: Map[EName, Elem] = {
    itemDecls.map(e => (EName(tns, e.attribute(EName("name"))) -> e)).toMap
}

val factElems = instanceDoc.documentElement \ { e =>
    e.resolvedName.namespaceUriOption == Some(helloWorldNamespace)
}

require(factElems.map(e => e.resolvedName).toSet.subsetOf(
    itemDeclsByTargetENames.keySet))
</code></pre>

<p>Prefixes are insignificant in XML. Let HelloWorld2.xml be equivalent to HelloWorld.xml, except that the default namespace has been replaced by prefix "xs":<p>

<pre><code>val schemaDoc2: Document = docParser.parse(new File("/path/to/HelloWorld2.xsd"))
</code></pre>

<p>How can we easily assert that these documents are equivalent XML documents? To that end, yaidom offers so-called "resolved" elements, which contain only expanded (element and attribute) names, and no qualified names. Indeed:</p>

<pre><code>
val rootElem = schemaDoc.documentElement
val rootElem2 = schemaDoc2.documentElement

require(resolved.Elem(rootElem).removeAllInterElementWhitespace ==
    resolved.Elem(rootElem2).removeAllInterElementWhitespace)
</code></pre>

<p>To show that the yaidom query API is uniform, let's now query the schema document element as "resolved" element for its item declarations:</p>

<pre><code>val resolvedSchemaDocElem = resolved.Elem(schemaDoc.documentElement)

val resolvedItemDecls = findAllItemDeclarations(resolvedSchemaDocElem)
</code></pre>

<p>Sometimes we have a (mutable) JAXP DOM tree, and do not want to convert it to a yaidom immutable Elem tree. We can still use the yaidom query API to query those DOM elements. Function 'findAllItemDeclarations" can still be called:</p>

<pre><code>val dbf = DocumentBuilderFactory.newInstance
val db = dbf.newDocumentBuilder
val d = db.parse(new File("/path/to/HelloWorld.xsd"))

val wrapperDoc = dom.DomDocument(d)

val domItemDecls = findAllItemDeclarations(wrapperDoc.documentElement)
</code></pre>

<p>Sometimes we want to use immutable elements, and still have access to the ancestry of each element. For example, when querying for item declarations, we need to inspect the document element for the target namespace. With so-called "indexed" elements, each element has indeed access to its ancestry.</p>

<p>This time using "indexed" elements, we again query for item declarations, but this time we need no separate query for the target namespace:</p>

<pre><code>val indexedSchemaDoc = indexed.Document(schemaDoc)

val indexedItemDecls = findAllItemDeclarations(indexedSchemaDoc.documentElement)

val targetENames: Set[EName] =
    (indexedItemDecls map { e =>
        val tnsOption = e.rootElem \@ EName("targetNamespace")
        val name = e.attribute(EName("name"))
        EName(tnsOption, name)
    }).toSet

require(factElems.map(e => e.resolvedName).toSet.subsetOf(targetENames))
</code></pre>

<h3>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>... conclusion ...</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
