<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Yaidom queries by dvreeze</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Another Scala XML library</h1>
        <p>Yaidom is yet another Scala (immutable) DOM-like XML library.</p>


        <p class="view"><a href="https://github.com/dvreeze">View My GitHub Profile</a></p>

      </header>
      <section>
        <h3>
<a name="why-yet-another-scala-xml-library" class="anchor" href="#why-yet-another-scala-xml-library"><span class="octicon octicon-link"></span></a>Why yet another Scala XML library?</h3>

<p>XML processing in Java has never been really easy. Arguably, the simplest way to manipulate XML in Java is through XML data binding solutions, such as JAXB. Such solutions hide the XML, making it look like normal Java objects. In non-trivial mapping scenarios one easily ends up having to keep 2 perspectives on the same XML data in sync: the "Java object view" and the "XML view", however.</p>

<p>Hence, O-X mapping is not the best answer to XML processing. On the other hand, directly manipulating XML should not be that hard in the first place, however.</p>

<p>Scala could help make direct XML manipulation easy, by leveraging the Scala Collections API. The standard Scala XML API should have been the obvious choice. It predates Scala 2.8, however, and its namespace support is not as precise and clear as I would like it to be. Anti-XML aimed at being a better alternative, but that project seems abandoned. The third well-known Scala XML library is Scales XML, but this is not a DOM-like API.</p>

<p>It seems hard to find a Scala XML library having first-class namespace support, and offering precise and clear namespace handling. The best explanation of XML namespaces that I have come across is <a href="http://www.lenzconsulting.com/namespaces/">Understanding XML Namespaces</a>. It distinguishes between qualified names (such as my:foo) and expanded names (such as {http://my}foo, in James Clark notation). Many XML libraries blur this distinction, and therefore offer sub-par namespace support.</p>

<p>This was the most important reason to come up with an alternative Scala XML DOM-like library, called yaidom.</p>

<p>This is the first in a series of articles about yaidom. It introduces basic XML querying in yaidom.</p>

<h3>
<a name="using-xbrl-examples" class="anchor" href="#using-xbrl-examples"><span class="octicon octicon-link"></span></a>Using XBRL examples</h3>

<p>To illustrate yaidom, we use examples in the domain of XBRL.</p>

<h3>
<a name="example-yaidom-element-queries" class="anchor" href="#example-yaidom-element-queries"><span class="octicon octicon-link"></span></a>Example yaidom element queries</h3>

<p>... the main content of the article ...</p>

<h3>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>... conclusion ...</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
